// Generated by CoffeeScript 1.8.0
var ArrowItem,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ArrowItem = (function(_super) {
  var ARROW_HALF_WIDTH, ARROW_WIDTH, HEADER_HEIGHT, HEADER_WIDTH, PADDING_SIZE, calBodyPath, calDrection, calTailDrawPath, calTrianglePath, clearArrow, coodLength, coodLog, drawCoodToCanvas, updateArrowRect;

  __extends(ArrowItem, _super);

  ArrowItem.IDENTITY = "arrow";

  ArrowItem.ITEMTYPE = Constant.ItemType.ARROW;

  ARROW_WIDTH = 37;

  ARROW_HALF_WIDTH = ARROW_WIDTH / 2.0;

  HEADER_WIDTH = 100;

  HEADER_HEIGHT = 50;

  PADDING_SIZE = HEADER_WIDTH;

  function ArrowItem(cood) {
    if (cood == null) {
      cood = null;
    }
    ArrowItem.__super__.constructor.call(this, cood);
    this.direction = {
      x: 0,
      y: 0
    };
    this.coodRegist = [];
    this.coodHeadPart = [];
    this.coodLeftBodyPart = [];
    this.coodRightBodyPart = [];
  }

  ArrowItem.prototype.canvasElementId = function() {
    return this.getElementId() + '_canvas';
  };

  ArrowItem.prototype.draw = function(moveCood) {
    calDrection.call(this, this.coodRegist[this.coodRegist.length - 1], moveCood);
    drawingContext.beginPath();
    drawingContext.moveTo(moveCood.x, moveCood.y);
    this.coodRegist.push(moveCood);
    updateArrowRect.call(this, moveCood);
    clearArrow.call(this);
    calTailDrawPath.call(this);
    calBodyPath.call(this, moveCood);
    calTrianglePath.call(this, this.coodLeftBodyPart[this.coodLeftBodyPart.length - 1], this.coodRightBodyPart[this.coodRightBodyPart.length - 1]);
    drawCoodToCanvas.call(this, window.drawingContext);
    drawingContext.globalAlpha = 0.3;
    return drawingContext.stroke();
  };

  ArrowItem.prototype.endDraw = function(zindex) {
    var l, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    if (!ArrowItem.__super__.endDraw.call(this, zindex)) {
      return false;
    }
    _ref = this.coodRegist;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      l = _ref[_i];
      l.x -= this.itemSize.x;
      l.y -= this.itemSize.y;
    }
    _ref1 = this.coodLeftBodyPart;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      l = _ref1[_j];
      l.x -= this.itemSize.x;
      l.y -= this.itemSize.y;
    }
    _ref2 = this.coodRightBodyPart;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      l = _ref2[_k];
      l.x -= this.itemSize.x;
      l.y -= this.itemSize.y;
    }
    _ref3 = this.coodHeadPart;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      l = _ref3[_l];
      l.x -= this.itemSize.x;
      l.y -= this.itemSize.y;
    }
    this.makeElement();
    return true;
  };

  ArrowItem.prototype.reDraw = function() {
    return this.makeElement();
  };

  ArrowItem.prototype.makeElement = function() {
    var drawingCanvas, drawingContext;
    $(ElementCode.get().createItemElement(this)).appendTo('#main-wrapper');
    $('#' + this.canvasElementId()).attr('width', $('#' + this.getElementId()).width());
    $('#' + this.canvasElementId()).attr('height', $('#' + this.getElementId()).height());
    this.setupEvents();
    drawingCanvas = document.getElementById(this.canvasElementId());
    drawingContext = drawingCanvas.getContext('2d');
    drawingContext.beginPath();
    drawCoodToCanvas.call(this, drawingContext);
    drawingContext.fillStyle = "#00008B";
    drawingContext.fill();
    return true;
  };

  ArrowItem.prototype.generateMinimumObject = function() {
    var obj;
    obj = {
      itemType: Constant.ItemType.ARROW,
      a: this.itemSize,
      b: this.zindex,
      c: this.coodRegist,
      g: this.coodHeadPart,
      h: this.coodLeftBodyPart,
      i: this.coodRightBodyPart
    };
    return obj;
  };

  ArrowItem.prototype.loadByMinimumObject = function(obj) {
    this.itemSize = obj.a;
    this.zindex = obj.b;
    this.coodRegist = obj.c;
    this.coodHeadPart = obj.g;
    this.coodLeftBodyPart = obj.h;
    this.coodRightBodyPart = obj.i;
    this.makeElement();
    return this.save(Constant.ItemActionType.MAKE);
  };

  coodLength = function(locA, locB) {
    return parseInt(Math.sqrt(Math.pow(locA.x - locB.x, 2) + Math.pow(locA.y - locB.y, 2)));
  };

  calDrection = function(beforeLoc, cood) {
    var x, y;
    if ((beforeLoc == null) || (cood == null)) {
      return;
    }
    if (beforeLoc.x < cood.x) {
      x = 1;
    } else if (beforeLoc.x === cood.x) {
      x = 0;
    } else {
      x = -1;
    }
    if (beforeLoc.y < cood.y) {
      y = 1;
    } else if (beforeLoc.y === cood.y) {
      y = 0;
    } else {
      y = -1;
    }
    return this.direction = {
      x: x,
      y: y
    };
  };

  calTrianglePath = function(leftCood, rightCood) {
    var leftTop, mid, r, rightTop, sita, sitaRight, sitaTop, top;
    if ((leftCood == null) || (rightCood == null)) {
      return null;
    }
    r = {
      x: leftCood.x - rightCood.x,
      y: leftCood.y - rightCood.y
    };
    sita = Math.atan2(r.y, r.x);
    leftTop = {
      x: Math.cos(sita) * (HEADER_WIDTH + ARROW_WIDTH) / 2.0 + rightCood.x,
      y: Math.sin(sita) * (HEADER_WIDTH + ARROW_WIDTH) / 2.0 + rightCood.y
    };
    sitaRight = sita + Math.PI;
    rightTop = {
      x: Math.cos(sitaRight) * (HEADER_WIDTH - ARROW_WIDTH) / 2.0 + rightCood.x,
      y: Math.sin(sitaRight) * (HEADER_WIDTH - ARROW_WIDTH) / 2.0 + rightCood.y
    };
    sitaTop = sita + Math.PI / 2.0;
    mid = {
      x: (leftCood.x + rightCood.x) / 2.0,
      y: (leftCood.y + rightCood.y) / 2.0
    };
    top = {
      x: Math.cos(sitaTop) * HEADER_HEIGHT + mid.x,
      y: Math.sin(sitaTop) * HEADER_HEIGHT + mid.y
    };
    return this.coodHeadPart = [rightTop, top, leftTop];
  };

  calTailDrawPath = function() {

    /* 検証 */
    var locSub, locTail, rad, validate;
    validate = function() {
      return this.coodRegist.length === 2;
    };
    if (!validate.call(this)) {
      return;
    }
    locTail = this.coodRegist[0];
    locSub = this.coodRegist[1];
    rad = Math.atan2(locSub.y - locTail.y, locSub.x - locTail.x);
    this.coodRightBodyPart.push({
      x: -(Math.sin(rad) * ARROW_HALF_WIDTH) + locTail.x,
      y: Math.cos(rad) * ARROW_HALF_WIDTH + locTail.y
    });
    return this.coodLeftBodyPart.push({
      x: Math.sin(rad) * ARROW_HALF_WIDTH + locTail.x,
      y: -(Math.cos(rad) * ARROW_HALF_WIDTH) + locTail.y
    });
  };

  calBodyPath = function() {

    /* 検証 */
    var calCenterBodyCood, centerBodyCood, locLeftBody, locRightBody, suitCoodBasedDirection, validate;
    validate = function() {
      return this.coodRegist.length >= 3;
    };

    /* 3点から引く座標を求める */
    calCenterBodyCood = function(left, center, right) {
      var cos, l, leftLength, leftX, leftY, r, rad, ret, rightLength, rightX, rightY, vectorRad;
      leftLength = coodLength.call(this, left, center);
      rightLength = coodLength.call(this, right, center);
      l = {
        x: left.x - center.x,
        y: left.y - center.y
      };
      r = {
        x: right.x - center.x,
        y: right.y - center.y
      };
      cos = (l.x * r.x + l.y * r.y) / (leftLength * rightLength);
      if (cos < -1) {
        cos = -1.0;
      }
      if (cos > 1) {
        cos = 1.0;
      }
      vectorRad = Math.acos(cos);
      rad = Math.atan2(r.y, r.x) + (vectorRad / 2.0);
      leftX = parseInt(Math.cos(rad + Math.PI) * ARROW_HALF_WIDTH + center.x);
      leftY = parseInt(Math.sin(rad + Math.PI) * ARROW_HALF_WIDTH + center.y);
      rightX = parseInt(Math.cos(rad) * ARROW_HALF_WIDTH + center.x);
      rightY = parseInt(Math.sin(rad) * ARROW_HALF_WIDTH + center.y);
      ret = {
        coodLeftPart: {
          x: leftX,
          y: leftY
        },
        coodRightPart: {
          x: rightX,
          y: rightY
        }
      };
      return ret;
    };

    /* 進行方向から最適化 */
    suitCoodBasedDirection = function(cood) {
      var beforeLeftCood, beforeRightCood, leftCood, ret, rightCood, suitCood;
      suitCood = function(cood, beforeCood) {
        if (this.direction.x < 0 && beforeCood.x < cood.x) {
          cood.x = beforeCood.x;
        } else if (this.direction.x > 0 && beforeCood.x > cood.x) {
          cood.x = beforeCood.x;
        }
        if (this.direction.y < 0 && beforeCood.y < cood.y) {
          cood.y = beforeCood.y;
        } else if (this.direction.y > 0 && beforeCood.y > cood.y) {
          cood.y = beforeCood.y;
        }
        return cood;
      };
      beforeLeftCood = this.coodLeftBodyPart[this.coodLeftBodyPart.length - 1];
      beforeRightCood = this.coodRightBodyPart[this.coodRightBodyPart.length - 1];
      leftCood = suitCood.call(this, cood.coodLeftPart, beforeLeftCood);
      rightCood = suitCood.call(this, cood.coodRightPart, beforeRightCood);
      ret = {
        coodLeftPart: leftCood,
        coodRightPart: rightCood
      };
      return ret;
    };
    if (!validate.call(this)) {
      return;
    }
    locLeftBody = this.coodLeftBodyPart[this.coodLeftBodyPart.length - 1];
    locRightBody = this.coodRightBodyPart[this.coodRightBodyPart.length - 1];
    centerBodyCood = calCenterBodyCood.call(this, this.coodRegist[this.coodRegist.length - 3], this.coodRegist[this.coodRegist.length - 2], this.coodRegist[this.coodRegist.length - 1]);
    centerBodyCood = suitCoodBasedDirection.call(this, centerBodyCood);
    this.coodLeftBodyPart.push(centerBodyCood.coodLeftPart);
    return this.coodRightBodyPart.push(centerBodyCood.coodRightPart);
  };

  drawCoodToCanvas = function(drawingContext) {
    var i, _i, _j, _k, _ref, _ref1, _ref2;
    if (this.coodLeftBodyPart.length <= 0 || this.coodRightBodyPart.length <= 0) {
      return;
    }
    drawingContext.moveTo(this.coodLeftBodyPart[this.coodLeftBodyPart.length - 1].x, this.coodLeftBodyPart[this.coodLeftBodyPart.length - 1].y);
    if (this.coodLeftBodyPart.length >= 2) {
      for (i = _i = _ref = this.coodLeftBodyPart.length - 2; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        drawingContext.lineTo(this.coodLeftBodyPart[i].x, this.coodLeftBodyPart[i].y);
      }
    }
    for (i = _j = 0, _ref1 = this.coodRightBodyPart.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      drawingContext.lineTo(this.coodRightBodyPart[i].x, this.coodRightBodyPart[i].y);
    }
    for (i = _k = 0, _ref2 = this.coodHeadPart.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
      drawingContext.lineTo(this.coodHeadPart[i].x, this.coodHeadPart[i].y);
    }
    return drawingContext.closePath();
  };

  clearArrow = function() {
    return this.restoreDrawingSurface(this.itemSize);
  };

  updateArrowRect = function(cood) {
    var maxX, maxY, minX, minY;
    if (this.itemSize === null) {
      return this.itemSize = {
        x: cood.x,
        y: cood.y,
        w: 0,
        h: 0
      };
    } else {
      minX = cood.x - PADDING_SIZE;
      minX = minX < 0 ? 0 : minX;
      minY = cood.y - PADDING_SIZE;
      minY = minY < 0 ? 0 : minY;
      maxX = cood.x + PADDING_SIZE;
      maxX = maxX > drawingCanvas.width ? drawingCanvas.width : maxX;
      maxY = cood.y + PADDING_SIZE;
      maxY = maxY > drawingCanvas.height ? drawingCanvas.height : maxY;
      if (this.itemSize.x > minX) {
        this.itemSize.w += this.itemSize.x - minX;
        this.itemSize.x = minX;
      }
      if (this.itemSize.x + this.itemSize.w < maxX) {
        this.itemSize.w += maxX - (this.itemSize.x + this.itemSize.w);
      }
      if (this.itemSize.y > minY) {
        this.itemSize.h += this.itemSize.y - minY;
        this.itemSize.y = minY;
      }
      if (this.itemSize.y + this.itemSize.h < maxY) {
        return this.itemSize.h += maxY - (this.itemSize.y + this.itemSize.h);
      }
    }
  };

  coodLog = function(cood, name) {
    return console.log(name + 'X:' + cood.x + ' ' + name + 'Y:' + cood.y);
  };

  return ArrowItem;

})(ItemBase);

//# sourceMappingURL=arrow.js.map
