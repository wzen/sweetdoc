// Generated by CoffeeScript 1.9.2
var PreloadItemText,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PreloadItemText = (function(superClass) {
  var _calcFontSizeAbout, _calcWordMeasure, _drawBalloon, _drawText, _drawTextAndBalloonToCanvas, _getRandomInt, _isWordNeedRotate, _isWordSmallJapanease, _measureImage, _prepareEditModal, _setNoTextStyle, _setTextStyle, _settingTextDbclickEvent, _showInputModal, _startCloseAnimation, _startOpenAnimation, constant;

  extend(PreloadItemText, superClass);

  PreloadItemText.NAME_PREFIX = "text";

  PreloadItemText.CLASS_DIST_TOKEN = 'PreloadItemText';

  PreloadItemText.NO_TEXT = 'No Text';

  PreloadItemText.WRITE_TEXT_BLUR_LENGTH = 3;

  if (typeof gon !== "undefined" && gon !== null) {
    constant = gon["const"];
    PreloadItemText.BalloonType = (function() {
      function BalloonType() {}

      BalloonType.FREE = constant.PreloadItemText.BalloonType.FREE;

      BalloonType.ARC = constant.PreloadItemText.BalloonType.ARC;

      BalloonType.RECT = constant.PreloadItemText.BalloonType.RECT;

      BalloonType.BROKEN_ARC = constant.PreloadItemText.BalloonType.BROKEN_ARC;

      BalloonType.BROKEN_RECT = constant.PreloadItemText.BalloonType.BROKEN_RECT;

      BalloonType.FLASH = constant.PreloadItemText.BalloonType.FLASH;

      BalloonType.CLOUD = constant.PreloadItemText.BalloonType.CLOUD;

      return BalloonType;

    })();
    PreloadItemText.WordAlign = (function() {
      function WordAlign() {}

      WordAlign.LEFT = constant.PreloadItemText.WordAlign.LEFT;

      WordAlign.CENTER = constant.PreloadItemText.WordAlign.CENTER;

      WordAlign.RIGHT = constant.PreloadItemText.WordAlign.RIGHT;

      return WordAlign;

    })();
    PreloadItemText.ShowAnimationType = (function() {
      function ShowAnimationType() {}

      ShowAnimationType.POPUP = constant.PreloadItemText.ShowAnimationType.POPUP;

      ShowAnimationType.BLUR = constant.PreloadItemText.ShowAnimationType.BLUR;

      return ShowAnimationType;

    })();
  }

  PreloadItemText.actionProperties = {
    modifiables: {
      textColor: {
        name: 'TextColor',
        "default": {
          r: 0,
          g: 0,
          b: 0
        },
        colorType: 'rgb',
        type: 'color',
        ja: {
          name: '文字色'
        }
      },
      showWithAnimation: {
        name: 'Show with animation',
        "default": false,
        type: 'boolean',
        openChildrenValue: true,
        ja: {
          name: 'アニメーション表示'
        },
        children: {
          showAnimetionType: {
            name: 'AnimationType',
            type: 'select',
            "default": PreloadItemText.ShowAnimationType.POPUP,
            options: [
              {
                name: 'Popup',
                value: PreloadItemText.ShowAnimationType.POPUP
              }, {
                name: 'Blur',
                value: PreloadItemText.ShowAnimationType.BLUR
              }
            ]
          },
          showAnimationDuration: {
            type: 'number',
            name: "Animation Duration",
            "default": 0.5,
            min: 0.1,
            max: 3.0,
            stepValue: 0.1
          }
        }
      },
      isDrawHorizontal: {
        name: 'Horizontal',
        type: 'boolean'
      },
      showBalloon: {
        name: 'Show Balloon',
        "default": false,
        type: 'boolean',
        openChildrenValue: true,
        ja: {
          name: '吹き出し表示'
        },
        children: {
          balloonColor: {
            name: 'BalloonColor',
            "default": '#fff',
            type: 'color',
            colorType: 'hex',
            ja: {
              name: '吹き出しの色'
            }
          },
          balloonType: {
            name: 'BalloonType',
            type: 'select',
            options: [
              {
                name: 'Arc',
                value: PreloadItemText.BalloonType.ARC
              }, {
                name: 'Broken Arc',
                value: PreloadItemText.BalloonType.BROKEN_ARC
              }, {
                name: 'Rect',
                value: PreloadItemText.BalloonType.RECT
              }, {
                name: 'Broken Rect',
                value: PreloadItemText.BalloonType.BROKEN_RECT
              }, {
                name: 'FLASH',
                value: PreloadItemText.BalloonType.FLASH
              }, {
                name: 'Cloud',
                value: PreloadItemText.BalloonType.CLOUD
              }
            ],
            openChildrenValue: [PreloadItemText.BalloonType.RECT, PreloadItemText.BalloonType.BROKEN_RECT],
            children: {
              balloonRadius: {
                name: 'BalloonRadius',
                "default": 30,
                type: 'number',
                min: 1,
                max: 100,
                ja: {
                  name: '吹き出しの角丸'
                }
              }
            }
          }
        }
      },
      fontFamily: {
        name: "Select Font",
        type: 'select',
        temp: 'fontFamily',
        ja: {
          name: 'フォント選択'
        }
      },
      isFixedFontSize: {
        name: "Font Size Fixed",
        type: 'boolean',
        "default": false,
        openChildrenValue: true,
        children: {
          fontSize: {
            type: 'number',
            name: "Font Size",
            min: 1,
            max: 100
          }
        }
      },
      wordAlign: {
        name: "Word Align",
        type: 'select',
        options: [
          {
            name: 'left',
            value: PreloadItemText.WordAlign.LEFT
          }, {
            name: 'center',
            value: PreloadItemText.WordAlign.CENTER
          }, {
            name: 'right',
            value: PreloadItemText.WordAlign.RIGHT
          }
        ]
      }
    },
    methods: {
      changeText: {
        modifiables: {
          inputText: {
            name: "Text",
            type: 'string',
            ja: {
              name: "文字"
            }
          }
        },
        options: {
          id: 'changeText',
          name: 'changeText',
          desc: "changeText",
          ja: {
            name: 'テキスト',
            desc: 'テキスト変更'
          }
        }
      },
      writeText: {
        options: {
          id: 'writeText',
          name: 'writeText',
          desc: "writeText",
          ja: {
            name: 'テキスト',
            desc: 'テキスト描画'
          }
        }
      }
    }
  };

  PreloadItemText.getCircumPos = {
    x: function(d, r, cx) {
      return Math.cos(Math.PI / 180 * d) * r + cx;
    },
    y: function(d, r, cy) {
      return Math.sin(Math.PI / 180 * d) * r + cy;
    }
  };

  function PreloadItemText(cood) {
    if (cood == null) {
      cood = null;
    }
    PreloadItemText.__super__.constructor.call(this, cood);
    if (cood !== null) {
      this._moveLoc = {
        x: cood.x,
        y: cood.y
      };
    }
    this.inputText = null;
    this.isDrawHorizontal = true;
    this.fontFamily = 'Times New Roman';
    this.fontSize = null;
    this.isFixedFontSize = false;
    this.showBalloon = false;
    this.balloonValue = {};
    this.balloonType = null;
    this.balloonRandomIntValue = null;
    this.textPositions = null;
    this.wordAlign = this.constructor.WordAlign.LEFT;
    this._fontMeatureCache = {};
    this._fixedTextAlpha = null;
  }

  PreloadItemText.prototype.itemDraw = function(show) {
    if (show == null) {
      show = true;
    }
    PreloadItemText.__super__.itemDraw.call(this, show);
    if (this.inputText != null) {
      _setTextStyle.call(this);
    } else {
      _setNoTextStyle.call(this);
    }
    if (this.inputText != null) {
      return _drawTextAndBalloonToCanvas.call(this, this.inputText);
    } else {
      return _drawTextAndBalloonToCanvas.call(this, this.constructor.NO_TEXT);
    }
  };

  PreloadItemText.prototype.refresh = function(show, callback) {
    if (show == null) {
      show = true;
    }
    if (callback == null) {
      callback = null;
    }
    return PreloadItemText.__super__.refresh.call(this, show, (function(_this) {
      return function() {
        _settingTextDbclickEvent.call(_this);
        if (callback != null) {
          return callback();
        }
      };
    })(this));
  };

  PreloadItemText.prototype.setInstanceVar = function(varName, value) {
    var canvas, h, height, w, width;
    if (varName === 'isDrawHorizontal' && this.isDrawHorizontal !== value) {
      canvas = document.getElementById(this.canvasElementId());
      width = canvas.width;
      height = canvas.height;
      $(canvas).css({
        width: height + "px",
        height: width + "px"
      });
      $(canvas).attr({
        width: height,
        height: width
      });
      w = this.itemSize.w;
      h = this.itemSize.h;
      this.itemSize.w = h;
      this.itemSize.h = w;
    }
    return PreloadItemText.__super__.setInstanceVar.call(this, varName, value);
  };

  PreloadItemText.prototype.mouseUpDrawing = function(zindex, callback) {
    if (callback == null) {
      callback = null;
    }
    this.restoreAllDrawingSurface();
    return this.endDraw(zindex, true, (function(_this) {
      return function() {
        _this.setupItemEvents();
        _this.saveObj(true);
        _this.firstFocus = Common.firstFocusItemObj() === null;
        Navbar.setModeEdit();
        WorktableCommon.changeMode(Constant.Mode.EDIT);
        _showInputModal.call(_this);
        if (callback != null) {
          return callback();
        }
      };
    })(this));
  };

  PreloadItemText.prototype.startOpenAnimation = function() {
    this._timemax = 50;
    this._time = 0;
    this._pertime = 1;
    this.disableEventHandle();
    return Common.requestAnimationFrame(_startOpenAnimation);
  };

  _startOpenAnimation = function() {
    var emt, height, progressPercent, step1, step2, step3, width, writingLength, x, y;
    if (this._canvas == null) {
      this._canvas = document.getElementById(this.canvasElementId());
      this._context = this._canvas.getContext('2d');
      this._context.save();
    }
    this._context.clearRect(0, 0, canvas.width, canvas.height);
    emt = this.getJQueryElement();
    x = null;
    y = null;
    width = null;
    height = null;
    if (this.showAnimetionType === this.constructor.ShowAnimationType.POPUP) {
      step1 = 0.7;
      step2 = 0.8;
      step3 = 1;
      if (this._time / this._timemax < step1) {
        progressPercent = this._time / (this._timemax * step1);
        x = (this.itemSize.w * 0.5) + (((this.itemSize.w - this.itemSize.w * 0.9) * 0.5) - (this.itemSize.w * 0.5)) * progressPercent;
        y = (this.itemSize.h * 0.5) + (((this.itemSize.h - this.itemSize.h * 0.9) * 0.5) - (this.itemSize.h * 0.5)) * progressPercent;
        width = (this.itemSize.w * 0.9) * progressPercent;
        height = (this.itemSize.h * 0.9) * progressPercent;
        this._step1 = {
          x: x,
          y: y,
          width: width,
          height: height
        };
        this._time1 = this._time;
      } else if (this._time / this._timemax < step2) {
        progressPercent = (this._time - this._time1) / (this._timemax * (step2 - step1));
        x = this._step1.x + (((this.itemSize.w - this.itemSize.w * 0.8) * 0.5) - this._step1.x) * progressPercent;
        y = this._step1.y + (((this.itemSize.h - this.itemSize.h * 0.8) * 0.5) - this._step1.y) * progressPercent;
        width = this._step1.w + (this.itemSize.w * 0.8 - this._step1.w) * progressPercent;
        height = this._step1.h((this.itemSize.h * 0.8 - this._step1.h) * progressPercent);
        this._step2 = {
          x: x,
          y: y,
          width: width,
          height: height
        };
        this._time2 = this._time;
      } else if (this._time / this._timemax < step3) {
        progressPercent = (this._time - this._time2) / (this._timemax * (step3 - step2));
        x = this._step2.x - this._step2.x * progressPercent;
        y = this._step2.y - this._step2.y * progressPercent;
        width = this._step2.w + (this.itemSize.w - this._step2.w) * progressPercent;
        height = this._step2.h + (this.itemSize.h - this._step2.h) * progressPercent;
      }
    } else if (this.showAnimetionType === this.constructor.ShowAnimationType.BLUR) {
      step1 = 1;
      if (this._time / this._timemax < step1) {
        progressPercent = this._time / (this._timemax * step1);
        this._context.globalAlpha = progressPercent;
      }
    }
    _drawBalloon.call(this, this._context, x, y, width, height);
    writingLength = this.getEventMethodName() === 'changeText' ? this.inputText.length : 0;
    _drawText.call(this, this._context, text, x, y, width, height, writingLength);
    this._time += this._pertime;
    if (this._time <= this._timemax) {
      return Common.requestAnimationFrame(_startOpenAnimation);
    } else {
      this._context.restore();
      return this.enableEventHandle();
    }
  };

  PreloadItemText.prototype.startCloseAnimation = function() {
    this._timemax = 50;
    this._time = 0;
    this._pertime = 1;
    this.disableEventHandle();
    return Common.requestAnimationFrame(_startCloseAnimation);
  };

  _startCloseAnimation = function() {
    var emt, height, progressPercent, step1, width, x, y;
    if (this._canvas == null) {
      this._canvas = document.getElementById(this.canvasElementId());
      this._context = this._canvas.getContext('2d');
      this._context.save();
    }
    this._context.clearRect(0, 0, canvas.width, canvas.height);
    emt = this.getJQueryElement();
    x = null;
    y = null;
    width = null;
    height = null;
    if (this.showAnimetionType === this.constructor.ShowAnimationType.POPUP) {
      step1 = 1;
      if (this._time / this._timemax < step1) {
        progressPercent = this._time / (this._timemax * step1);
        x = (this.itemSize.w * 0.5) * progressPercent;
        y = (this.itemSize.h * 0.5) * progressPercent;
        width = this.itemSize.w - this.itemSize.w * progressPercent;
        height = this.itemSize.h - this.itemSize.h * progressPercent;
      }
    } else if (this.showAnimetionType === this.constructor.ShowAnimationType.BLUR) {
      step1 = 1;
      if (this._time / this._timemax < step1) {
        progressPercent = 1 - (this._time / (this._timemax * step1));
        this._context.globalAlpha = progressPercent;
      }
    }
    _drawBalloon.call(this, this._context, x, y, width, height);
    _drawText.call(this, this._context, text, x, y, width, height, this.inputText.length);
    this._time += this._pertime;
    if (this._time <= this._timemax) {
      return Common.requestAnimationFrame(_startOpenAnimation);
    } else {
      this._context.restore();
      return this.enableEventHandle();
    }
  };

  PreloadItemText.prototype.willChapter = function() {
    var canvas, context;
    PreloadItemText.__super__.willChapter.call(this);
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    return context.clearRect(0, 0, canvas.width, canvas.height);
  };

  PreloadItemText.isJapanease = function(c) {
    return c.charCodeAt(0) >= 256;
  };

  PreloadItemText.prototype.changeText = function(opt) {
    var canvas, context, opa;
    if (opt.progress === 0 && this.showWithAnimation) {
      this.startOpenAnimation();
    }
    opa = opt.progress / opt.progressMax;
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = "rgb(" + this.textColor.r + "," + this.textColor.g + "," + this.textColor.b + ")";
    this._fixedTextAlpha = 1 - opa;
    _drawTextAndBalloonToCanvas.call(this, this.inputText__before);
    this._fixedTextAlpha = opa;
    _drawTextAndBalloonToCanvas.call(this, this.inputText__after);
    if (opt.progress === opt.progressMax && this.showWithAnimation) {
      return this.startCloseAnimation();
    }
  };

  PreloadItemText.prototype.writeText = function(opt) {
    var canvas, context;
    if (opt.progress === 0 && this.showWithAnimation) {
      this.startOpenAnimation();
    }
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
    this._fixedTextAlpha = null;
    if ((this.inputText != null) && this.inputText.length > 0) {
      _setTextStyle.call(this);
      _drawTextAndBalloonToCanvas.call(this, this.inputText, this.inputText.length * opt.progress / opt.progressMax);
    }
    if (opt.progress === opt.progressMax && this.showWithAnimation) {
      return this.startCloseAnimation();
    }
  };

  _setTextStyle = function() {
    var canvas, context;
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    return context.fillStyle = this.textColor;
  };

  _setNoTextStyle = function() {
    var canvas, context;
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    return context.fillStyle = 'rgba(33, 33, 33, 0.3)';
  };

  _drawTextAndBalloonToCanvas = function(text, writingLength) {
    var canvas, context;
    if (text == null) {
      return;
    }
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    _drawBalloon.call(this, context, 0, 0, canvas.width, canvas.height);
    return _drawText.call(this, context, text, 0, 0, canvas.width, canvas.height, writingLength);
  };

  _getRandomInt = function(max, min) {
    return Math.floor(Math.random() * (max - min)) + min;
  };

  _drawBalloon = function(context, x, y, width, height) {
    var _drawArc, _drawBArc, _drawBRect, _drawRect, _drawShout, _drawThink;
    if (!this.showBalloon) {
      return;
    }
    _drawArc = function() {
      var diff;
      context.beginPath();
      context.translate(width * 0.5, height * 0.5);
      diff = 3.0;
      if (width > height) {
        context.scale(width / height, 1);
        context.arc(x, y, height * 0.5 - diff, 0, Math.PI * 2);
      } else {
        context.scale(1, height / width);
        context.arc(x, y, width * 0.5 - diff, 0, Math.PI * 2);
      }
      context.fillStyle = 'rgba(255, 255, 255, 0.5)';
      context.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      context.fill();
      return context.stroke();
    };
    _drawRect = function() {
      context.beginPath();
      context.fillStyle = 'rgba(255, 255, 255, 0.5)';
      context.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      return context.fillRect(x, y, width, height);
    };
    _drawBArc = function() {
      var diff, l, per, results, results1, sum;
      diff = 3.0;
      context.translate(width * 0.5, height * 0.5);
      context.fillStyle = 'rgba(255, 255, 255, 0.5)';
      context.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      per = Math.PI * 2 / 100;
      if (width > height) {
        context.scale(width / height, 1);
        sum = 0;
        x = 0;
        results = [];
        while (sum < Math.PI * 2) {
          context.beginPath();
          l = ((2 * Math.abs(Math.cos(x))) + 1) * per;
          y = x + l;
          context.arc(x, y, height * 0.5 - diff, x, y);
          context.fill();
          context.stroke();
          sum += l;
          x = y;
          l = ((1 * Math.abs(Math.cos(x))) + 1) * per;
          y = x + l;
          sum += l;
          results.push(x = y);
        }
        return results;
      } else {
        context.scale(1, height / width);
        sum = 0;
        x = 0;
        results1 = [];
        while (sum < Math.PI * 2) {
          context.beginPath();
          l = ((2 * Math.abs(Math.sin(x))) + 1) * per;
          y = x + l;
          context.arc(x, y, width * 0.5 - diff, x, y);
          context.fill();
          context.stroke();
          sum += l;
          x = y;
          l = ((1 * Math.abs(Math.sin(x))) + 1) * per;
          y = x + l;
          sum += l;
          results1.push(x = y);
        }
        return results1;
      }
    };
    _drawBRect = function() {
      var _draw, dashLength;
      context.save();
      dashLength = 5;
      context.beginPath();
      _draw = function(sx, sy, ex, ey) {
        var deltaX, deltaY, i, k, numDashes, ref, results;
        deltaX = ex - sx;
        deltaY = ey - sy;
        numDashes = Math.floor(Math.sqrt(deltaX * deltaX + deltaY * deltaY) / dashLength);
        results = [];
        for (i = k = 0, ref = numDashes - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          if (i % 2 === 0) {
            results.push(context.moveTo(sx + (deltaX / numDashes) * i, sy + (deltaY / numDashes) * i));
          } else {
            results.push(context.lineTo(sx + (deltaX / numDashes) * i, sy + (deltaY / numDashes) * i));
          }
        }
        return results;
      };
      _draw.call(this, x, y, width, y);
      _draw.call(this, width, y, width, height);
      _draw.call(this, width, height, x, height);
      _draw.call(this, x, height, x, y);
      context.fillStyle = 'rgba(255, 255, 255, 0.5)';
      context.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      context.fillRect(x, y, width, height);
      context.stroke();
      return context.restore();
    };
    _drawShout = (function(_this) {
      return function() {
        var addDeg, beginX, beginY, cp1x, cp1y, cp2x, cp2y, cx, cy, deg, endX, endY, i, k, num, punkLineMax, punkLineMin, radiusX, radiusY, random, ref;
        num = 18;
        radiusX = width / 2;
        radiusY = height / 2;
        cx = width / 2;
        cy = height / 2;
        punkLineMax = 30;
        punkLineMin = 20;
        deg = 0;
        addDeg = 360 / num;
        context.beginPath();
        context.lineJoin = 'round';
        context.lineCap = 'round';
        context.fillStyle = 'rgba(255,255,255,0.9)';
        context.strokeStyle = 'black';
        for (i = k = 0, ref = num - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          deg += addDeg;
          if (_this.balloonRandomIntValue == null) {
            _this.balloonRandomIntValue = _getRandomInt.call(_this, punkLineMax, punkLineMin);
          }
          random = _this.balloonRandomIntValue;
          beginX = PreloadItemText.getCircumPos.x(deg, radiusX, cx);
          beginY = PreloadItemText.getCircumPos.y(deg, radiusY, cy);
          endX = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX, cx);
          endY = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY, cy);
          cp1x = PreloadItemText.getCircumPos.x(deg, radiusX - random * 0.6, cx);
          cp1y = PreloadItemText.getCircumPos.y(deg, radiusY - random * 0.6, cy);
          cp2x = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX - random * 0.6, cx);
          cp2y = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY - random * 0.6, cy);
          if (i === 0) {
            context.arcTo(beginX, beginY, endX, endY, punkLineMax);
          }
          context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
        }
        context.fill();
        return context.stroke();
      };
    })(this);
    _drawThink = (function(_this) {
      return function() {
        var addDeg, beginX, beginY, cp1x, cp1y, cp2x, cp2y, cx, cy, deg, diff, endX, endY, i, k, num, punkLineMax, punkLineMin, radiusX, radiusY, random, ref;
        num = 10;
        diff = 40.0;
        radiusX = (width - diff) / 2;
        radiusY = (height - diff) / 2;
        cx = width / 2;
        cy = height / 2;
        punkLineMax = 30;
        punkLineMin = 20;
        deg = 0;
        addDeg = 360 / num;
        context.beginPath();
        context.lineJoin = 'round';
        context.lineCap = 'round';
        context.fillStyle = 'rgba(255,255,255,0.9)';
        context.strokeStyle = 'black';
        for (i = k = 0, ref = num - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          deg += addDeg;
          if (_this.balloonRandomIntValue == null) {
            _this.balloonRandomIntValue = _getRandomInt.call(_this, punkLineMax, punkLineMin);
          }
          random = _this.balloonRandomIntValue;
          beginX = PreloadItemText.getCircumPos.x(deg, radiusX, cx);
          beginY = PreloadItemText.getCircumPos.y(deg, radiusY, cy);
          endX = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX, cx);
          endY = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY, cy);
          cp1x = PreloadItemText.getCircumPos.x(deg, radiusX + random * 0.8, cx);
          cp1y = PreloadItemText.getCircumPos.y(deg, radiusY + random * 0.8, cy);
          cp2x = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX + random * 0.8, cx);
          cp2y = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY + random * 0.8, cy);
          if (i === 0) {
            context.arcTo(beginX, beginY, endX, endY, punkLineMax);
          }
          context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
        }
        context.fill();
        return context.stroke();
      };
    })(this);
    context.save();
    if (this.balloonType === this.constructor.BalloonType.ARC) {
      _drawArc.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.RECT) {
      _drawRect.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.BROKEN_ARC) {
      _drawBArc.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.BROKEN_RECT) {
      _drawBRect.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.FLASH) {
      _drawShout.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.CLOUD) {
      _drawThink.call(this);
    }
    return context.restore();
  };

  _drawText = function(context, text, x, y, width, height, writingLength) {
    var _calcHorizontalColumnHeightMax, _calcHorizontalColumnWidth, _calcHorizontalColumnWidthMax, _calcSize, _calcVerticalColumnHeight, _calcVerticalColumnHeightMax, _setTextAlpha, _writeLength, c, char, column, h, heightLine, heightMax, hl, i, idx, j, k, len, len1, line, m, measure, n, o, p, ref, ref1, ref2, ref3, ref4, sizeSum, w, widthLine, widthMax, wl, wordSum, wordWidth;
    if (writingLength == null) {
      writingLength = text.length;
    }
    context.save();
    if (this.fontSize == null) {
      _calcFontSizeAbout.call(this, text, width, height);
    }
    context.font = this.fontSize + "px " + this.fontFamily;
    wordWidth = context.measureText('あ').width;
    _calcSize = function(columnText) {
      var hasJapanease, i, k, ref;
      hasJapanease = false;
      for (i = k = 0, ref = columnText.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        if (PreloadItemText.isJapanease(columnText.charAt(i))) {
          hasJapanease = true;
          break;
        }
      }
      if (hasJapanease) {
        return context.measureText('あ').width;
      } else {
        return context.measureText('W').width;
      }
    };
    _calcHorizontalColumnWidth = function(columnText) {
      var char, k, len, ref, sum;
      sum = 0;
      ref = columnText.split('');
      for (k = 0, len = ref.length; k < len; k++) {
        char = ref[k];
        sum += context.measureText(char).width;
      }
      return sum;
    };
    _calcVerticalColumnHeight = function(columnText) {
      return columnText.length * context.measureText('あ').width;
    };
    _calcHorizontalColumnHeightMax = function(columnText) {
      var c, k, len, measure, r, ref, ret;
      ret = 0;
      ref = columnText.split('');
      for (k = 0, len = ref.length; k < len; k++) {
        c = ref[k];
        measure = _calcWordMeasure.call(this, c, this.fontSize, this.fontFamily, wordWidth);
        r = measure.height;
        if (ret < r) {
          ret = r;
        }
      }
      return ret;
    };
    _calcHorizontalColumnWidthMax = function(columns) {
      var c, k, len, r, ret;
      ret = 0;
      for (k = 0, len = columns.length; k < len; k++) {
        c = columns[k];
        r = _calcHorizontalColumnWidth.call(this, c);
        if (ret < r) {
          ret = r;
        }
      }
      return ret;
    };
    _calcVerticalColumnHeightMax = function(columns) {
      var c, k, len, r, ret;
      ret = 0;
      for (k = 0, len = columns.length; k < len; k++) {
        c = columns[k];
        r = _calcVerticalColumnHeight.call(this, c);
        if (ret < r) {
          ret = r;
        }
      }
      return ret;
    };
    _setTextAlpha = function(context, idx, writingLength) {
      var ga;
      if (this._fixedTextAlpha != null) {
        context.globalAlpha = this._fixedTextAlpha;
        return;
      }
      if (writingLength === 0) {
        return context.globalAlpha = 0;
      } else if (idx <= writingLength) {
        return context.globalAlpha = 1;
      } else {
        ga = 1 - ((idx - writingLength) / this.constructor.WRITE_TEXT_BLUR_LENGTH);
        if (ga < 0) {
          ga = 0;
        }
        return context.globalAlpha = ga;
      }
    };
    _writeLength = function(column, writingLength, wordSum) {
      var v;
      v = parseInt(writingLength - wordSum);
      if (v > column.length) {
        v = column.length;
      } else if (v < 0) {
        v = 0;
      }
      return v;
    };
    column = [''];
    line = 0;
    text = text.replace("{br}", "\n", "gm");
    for (i = k = 0, ref = text.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      char = text.charAt(i);
      if (char === "\n" || (this.isDrawHorizontal && context.measureText(column[line] + char).width > width) || (!this.isDrawHorizontal && _calcVerticalColumnHeight.call(this, column[line] + char) > height)) {
        line += 1;
        column[line] = '';
        if (char === "\n") {
          char = '';
        }
      }
      column[line] += char;
    }
    sizeSum = 0;
    wordSum = 0;
    if (this.isDrawHorizontal) {
      heightLine = (height - wordWidth * column.length) * 0.5;
      widthMax = _calcHorizontalColumnWidthMax.call(this, column);
      for (j = m = 0, ref1 = column.length - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; j = 0 <= ref1 ? ++m : --m) {
        heightLine += _calcHorizontalColumnHeightMax.call(this, column[j]);
        w = x;
        if (this.wordAlign === this.constructor.WordAlign.LEFT) {
          w += (width - widthMax) * 0.5;
        } else if (this.wordAlign === this.constructor.WordAlign.CENTER) {
          w += (width - _calcHorizontalColumnWidth.call(this, column[j])) * 0.5;
        } else {
          w += (width + widthMax) * 0.5 - _calcHorizontalColumnWidth.call(this, column[j]);
        }
        context.beginPath();
        wl = 0;
        ref2 = column[j].split('');
        for (idx = n = 0, len = ref2.length; n < len; idx = ++n) {
          c = ref2[idx];
          _setTextAlpha.call(this, context, idx + wordSum + 1, writingLength);
          context.fillText(c, w + wl, heightLine);
          wl += context.measureText(c).width;
        }
        wordSum += column[j].length;
      }
    } else {
      widthLine = (width + wordWidth * column.length) * 0.5;
      heightMax = _calcVerticalColumnHeightMax.call(this, column);
      for (j = o = 0, ref3 = column.length - 1; 0 <= ref3 ? o <= ref3 : o >= ref3; j = 0 <= ref3 ? ++o : --o) {
        widthLine -= wordWidth;
        h = y;
        if (this.wordAlign === this.constructor.WordAlign.LEFT) {
          h += (height - heightMax) * 0.5;
        } else if (this.wordAlign === this.constructor.WordAlign.CENTER) {
          h += (height - _calcVerticalColumnHeight.call(this, column[j])) * 0.5;
        } else {
          h += (height + heightMax) * 0.5 - _calcVerticalColumnHeight.call(this, column[j]);
        }
        context.beginPath();
        hl = 0;
        ref4 = column[j].split('');
        for (idx = p = 0, len1 = ref4.length; p < len1; idx = ++p) {
          c = ref4[idx];
          measure = _calcWordMeasure.call(this, c, this.fontSize, this.fontFamily, wordWidth);
          _setTextAlpha.call(this, context, idx + wordSum + 1, writingLength);
          if (_isWordSmallJapanease.call(this, c)) {
            context.fillText(c, widthLine + (wordWidth - measure.width) * 0.5, h + wordWidth + hl - (wordWidth - measure.height));
            hl += measure.height;
          } else if (_isWordNeedRotate.call(this, c)) {
            context.save();
            context.beginPath();
            context.translate(widthLine + wordWidth * 0.5, h + hl + measure.height);
            context.rotate(Math.PI / 2);
            context.fillText(c, -measure.width * 0.5, wordWidth * 0.75 * 0.5);
            context.restore();
            hl += measure.width;
          } else {
            context.fillText(c, widthLine, h + wordWidth + hl);
            if (PreloadItemText.isJapanease(c)) {
              hl += wordWidth;
            } else {
              hl += measure.height;
            }
          }
        }
        wordSum += column[j].length;
      }
    }
    return context.restore();
  };

  _calcWordMeasure = function(char, fontSize, fontFamily, wordSize) {
    var fontSizeKey, mi, nCanvas, nContext, writedImage;
    fontSizeKey = "" + fontSize;
    if ((this._fontMeatureCache[fontSizeKey] != null) && (this._fontMeatureCache[fontSizeKey][fontFamily] != null) && (this._fontMeatureCache[fontSizeKey][fontFamily][char] != null)) {
      return this._fontMeatureCache[fontSizeKey][fontFamily][char];
    }
    nCanvas = document.createElement('canvas');
    nCanvas.width = wordSize;
    nCanvas.height = wordSize;
    nContext = nCanvas.getContext('2d');
    nContext.font = fontSize + "px " + fontFamily;
    nContext.textBaseline = 'top';
    nContext.fillStyle = nCanvas.strokeStyle = '#ff0000';
    nContext.fillText(char, 0, 0);
    writedImage = nContext.getImageData(0, 0, wordSize, wordSize);
    mi = _measureImage.call(this, writedImage);
    if (this._fontMeatureCache[fontSizeKey] == null) {
      this._fontMeatureCache[fontSizeKey] = {};
    }
    if (this._fontMeatureCache[fontSizeKey][fontFamily] == null) {
      this._fontMeatureCache[fontSizeKey][fontFamily] = {};
    }
    this._fontMeatureCache[fontSizeKey][fontFamily][char] = mi;
    return mi;
  };

  _measureImage = function(_writedImage) {
    var i, k, maxX, maxY, minX, minY, ref, w, x, y;
    w = _writedImage.width;
    x = 0;
    y = 0;
    minX = 0;
    maxX = 1;
    minY = 0;
    maxY = 1;
    for (i = k = 0, ref = _writedImage.data.length - 1; k <= ref; i = k += 4) {
      if (_writedImage.data[i + 0] > 128) {
        if (x < minX) {
          minX = x;
        }
        if (x > maxX) {
          maxX = x;
        }
        if (y < minY) {
          minY = y;
        }
        if (y > maxY) {
          maxY = y;
        }
      }
      x += 1;
      if (x >= w) {
        x = 0;
        y += 1;
      }
    }
    return {
      width: maxX - minX + 1,
      height: maxY - minY + 1
    };
  };

  _isWordSmallJapanease = function(char) {
    var list, regex;
    list = '、。ぁぃぅぇぉっゃゅょゎァィゥェォっャュョヮヵヶ'.split('');
    list = list.concat([',', '\\.']);
    regex = new RegExp(list.join('|'));
    return char.match(regex);
  };

  _isWordNeedRotate = function(char) {
    var list, regex;
    if (!PreloadItemText.isJapanease(char)) {
      return true;
    }
    list = 'ー＝〜・';
    regex = new RegExp(list.split('').join('|'));
    return char.match(regex);
  };

  _calcFontSizeAbout = function(text, width, height) {
    var a, fontSize, h, newLineCount, w;
    a = text.length;
    text = text.replace(/\n+$/g, '');
    if (!this.isFixedFontSize) {
      newLineCount = text.split('\n').length - 1;
      if (this.isDrawHorizontal) {
        w = height;
        h = width;
      } else {
        w = width;
        h = height;
      }
      fontSize = (Math.sqrt(Math.pow(newLineCount, 2) + (w * 4 * (a + 1)) / h) - newLineCount) * h / ((a + 1) * 2);
      this.fontSize = parseInt(fontSize / 1.5);
      if (this.fontSize < 1) {
        return this.fontSize = 1;
      }
    }
  };

  _showInputModal = function() {
    return Common.showModalView(Constant.ModalViewType.ITEM_TEXT_EDITING, false, (function(_this) {
      return function(modalEmt, params, callback) {
        if (callback == null) {
          callback = null;
        }
        _prepareEditModal.call(_this, modalEmt);
        if (callback != null) {
          return callback();
        }
      };
    })(this));
  };

  _settingTextDbclickEvent = function() {
    return this.getJQueryElement().off('dblclick').on('dblclick', (function(_this) {
      return function(e) {
        e.preventDefault();
        return _showInputModal.call(_this);
      };
    })(this));
  };

  _prepareEditModal = function(modalEmt) {
    if (this.inputText != null) {
      $('.textarea:first', modalEmt).val(this.inputText);
    } else {
      $('.textarea:first', modalEmt).val('');
    }
    $('.create_button', modalEmt).off('click').on('click', (function(_this) {
      return function(e) {
        var emt;
        emt = $(e.target).closest('.modal-content');
        _this.inputText = $('.textarea:first', emt).val();
        _this.saveObj();
        return Navbar.setModeDraw(_this.classDistToken, function() {
          WorktableCommon.changeMode(Constant.Mode.DRAW);
          return _this.refresh(true, function() {
            return Common.hideModalView();
          });
        });
      };
    })(this));
    return $('.back_button', modalEmt).off('click').on('click', (function(_this) {
      return function(e) {
        return Common.hideModalView();
      };
    })(this));
  };

  return PreloadItemText;

})(CanvasItemBase);

Common.setClassToMap(PreloadItemText.CLASS_DIST_TOKEN, PreloadItemText);

if ((window.itemInitFuncList != null) && (window.itemInitFuncList[PreloadItemText.CLASS_DIST_TOKEN] == null)) {
  if (window.debug) {
    console.log('PreloadItemText loaded');
  }
  window.itemInitFuncList[PreloadItemText.CLASS_DIST_TOKEN] = function(option) {
    if (option == null) {
      option = {};
    }
    if (window.isWorkTable && (PreloadItemText.jsLoaded != null)) {
      PreloadItemArrow.jsLoaded(option);
    }
    if (window.debug) {
      return console.log('PreloadItemText init Finish');
    }
  };
}

//# sourceMappingURL=pi_text.js.map
