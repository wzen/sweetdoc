// Generated by CoffeeScript 1.9.2
var PreloadItemText,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PreloadItemText = (function(superClass) {
  var _adjustFreeHandPath, _calcFontSizeAbout, _calcHorizontalColumnHeightMax, _calcHorizontalColumnHeightSum, _calcHorizontalColumnWidth, _calcHorizontalColumnWidthMax, _calcRowWordLength, _calcVerticalColumnHeight, _calcVerticalColumnHeightMax, _calcWordMeasure, _defaultWorkWidth, _drawBalloon, _drawText, _drawTextAndBalloonToCanvas, _freeHandBalloonDraw, _getRandomInt, _isWordNeedRotate, _isWordSmallJapanease, _measureImage, _prepareEditModal, _setNoTextStyle, _setTextAlpha, _setTextStyle, _settingTextDbclickEvent, _showInputModal, _startCloseAnimation, _startOpenAnimation, _writeLength, constant;

  extend(PreloadItemText, superClass);

  PreloadItemText.NAME_PREFIX = "text";

  PreloadItemText.CLASS_DIST_TOKEN = 'PreloadItemText';

  PreloadItemText.NO_TEXT = 'Blank text';

  PreloadItemText.WRITE_TEXT_BLUR_LENGTH = 5;

  constant = gon["const"];

  PreloadItemText.BalloonType = (function() {
    function BalloonType() {}

    BalloonType.FREE = constant.PreloadItemText.BalloonType.FREE;

    BalloonType.ARC = constant.PreloadItemText.BalloonType.ARC;

    BalloonType.RECT = constant.PreloadItemText.BalloonType.RECT;

    BalloonType.BROKEN_ARC = constant.PreloadItemText.BalloonType.BROKEN_ARC;

    BalloonType.BROKEN_RECT = constant.PreloadItemText.BalloonType.BROKEN_RECT;

    BalloonType.FLASH = constant.PreloadItemText.BalloonType.FLASH;

    BalloonType.CLOUD = constant.PreloadItemText.BalloonType.CLOUD;

    return BalloonType;

  })();

  PreloadItemText.WriteDirectionType = (function() {
    function WriteDirectionType() {}

    WriteDirectionType.HORIZONTAL = constant.PreloadItemText.WriteDirectionType.HORIZONTAL;

    WriteDirectionType.VERTICAL = constant.PreloadItemText.WriteDirectionType.VERTICAL;

    return WriteDirectionType;

  })();

  PreloadItemText.WordAlign = (function() {
    function WordAlign() {}

    WordAlign.LEFT = constant.PreloadItemText.WordAlign.LEFT;

    WordAlign.CENTER = constant.PreloadItemText.WordAlign.CENTER;

    WordAlign.RIGHT = constant.PreloadItemText.WordAlign.RIGHT;

    return WordAlign;

  })();

  PreloadItemText.ShowAnimationType = (function() {
    function ShowAnimationType() {}

    ShowAnimationType.POPUP = constant.PreloadItemText.ShowAnimationType.POPUP;

    ShowAnimationType.FADE = constant.PreloadItemText.ShowAnimationType.FADE;

    return ShowAnimationType;

  })();

  PreloadItemText.actionProperties = {
    modifiables: {
      textColor: {
        name: 'TextColor',
        "default": {
          r: 0,
          g: 0,
          b: 0
        },
        colorType: 'rgb',
        type: 'color',
        ja: {
          name: '文字色'
        }
      },
      drawHorizontal: {
        name: 'Horizontal / Vertical',
        type: 'select',
        options: [
          {
            name: 'Horizontal',
            value: PreloadItemText.WriteDirectionType.HORIZONTAL,
            ja: {
              name: '横書き'
            }
          }, {
            name: 'Vertical',
            value: PreloadItemText.WriteDirectionType.VERTICAL,
            ja: {
              name: '縦書き'
            }
          }
        ],
        ja: {
          name: '横書き / 縦書き'
        }
      },
      showBalloon: {
        name: 'Show Balloon',
        "default": false,
        type: 'boolean',
        openChildrenValue: {
          one: true
        },
        ja: {
          name: '吹き出し表示'
        },
        children: {
          one: {
            balloonColor: {
              name: 'BalloonColor',
              "default": {
                r: 255,
                g: 255,
                b: 255
              },
              type: 'color',
              colorType: 'rgb',
              ja: {
                name: '吹き出しの色'
              }
            },
            balloonBorderColor: {
              name: 'BalloonBorderColor',
              "default": {
                r: 0,
                g: 0,
                b: 0
              },
              type: 'color',
              colorType: 'rgb',
              ja: {
                name: '吹き出し枠の色'
              }
            },
            balloonType: {
              name: 'BalloonType',
              type: 'select',
              options: [
                {
                  name: 'Arc',
                  value: PreloadItemText.BalloonType.ARC
                }, {
                  name: 'Broken Arc',
                  value: PreloadItemText.BalloonType.BROKEN_ARC
                }, {
                  name: 'Rect',
                  value: PreloadItemText.BalloonType.RECT
                }, {
                  name: 'Broken Rect',
                  value: PreloadItemText.BalloonType.BROKEN_RECT
                }, {
                  name: 'Flash',
                  value: PreloadItemText.BalloonType.FLASH
                }, {
                  name: 'Cloud',
                  value: PreloadItemText.BalloonType.CLOUD
                }, {
                  name: 'FreeHand',
                  value: PreloadItemText.BalloonType.FREE
                }
              ],
              ja: {
                name: '吹き出しのタイプ'
              },
              openChildrenValue: {
                one: PreloadItemText.BalloonType.RECT
              },
              children: {
                one: {
                  balloonRadius: {
                    name: 'BalloonRadius',
                    "default": 30,
                    type: 'number',
                    min: 1,
                    max: 100,
                    ja: {
                      name: '吹き出しの角丸'
                    }
                  }
                }
              }
            }
          }
        }
      },
      fontFamily: {
        name: "Select Font",
        type: 'select',
        temp: 'fontFamily',
        ja: {
          name: 'フォント選択'
        }
      },
      isFixedFontSize: {
        name: "Font Size Fixed",
        type: 'boolean',
        "default": false,
        openChildrenValue: {
          one: true
        },
        ja: {
          name: 'フォントサイズ'
        },
        children: {
          one: {
            fixedFontSize: {
              type: 'number',
              name: "Font Size",
              min: 1,
              max: 100,
              "default": 14
            }
          }
        }
      },
      wordAlign: {
        name: "Word Align",
        type: 'select',
        options: [
          {
            name: 'left',
            value: PreloadItemText.WordAlign.LEFT
          }, {
            name: 'center',
            value: PreloadItemText.WordAlign.CENTER
          }, {
            name: 'right',
            value: PreloadItemText.WordAlign.RIGHT
          }
        ],
        ja: {
          name: '文字寄せ'
        }
      }
    },
    methods: {
      changeText: {
        finishWithHand: true,
        modifiables: {
          inputText: {
            name: "Text",
            type: 'string',
            ja: {
              name: "文字"
            }
          },
          showWithAnimation: {
            name: 'Show with animation',
            "default": false,
            type: 'boolean',
            openChildrenValue: {
              one: true
            },
            ja: {
              name: 'アニメーション表示'
            },
            children: {
              one: {
                showAnimationType: {
                  name: 'AnimationType',
                  type: 'select',
                  "default": PreloadItemText.ShowAnimationType.POPUP,
                  options: [
                    {
                      name: 'Popup',
                      value: PreloadItemText.ShowAnimationType.POPUP
                    }, {
                      name: 'Fade',
                      value: PreloadItemText.ShowAnimationType.FADE
                    }
                  ]
                }
              }
            }
          }
        },
        options: {
          id: 'changeText',
          name: 'changeText',
          desc: "changeText",
          ja: {
            name: 'テキスト',
            desc: 'テキスト変更'
          }
        }
      },
      writeText: {
        finishWithHand: true,
        modifiables: {
          showWithAnimation: {
            name: 'Show with animation',
            "default": false,
            type: 'boolean',
            openChildrenValue: {
              one: true
            },
            ja: {
              name: 'アニメーション表示'
            },
            children: {
              one: {
                showAnimationType: {
                  name: 'AnimationType',
                  type: 'select',
                  "default": PreloadItemText.ShowAnimationType.POPUP,
                  options: [
                    {
                      name: 'Popup',
                      value: PreloadItemText.ShowAnimationType.POPUP
                    }, {
                      name: 'Blur',
                      value: PreloadItemText.ShowAnimationType.FADE
                    }
                  ]
                }
              }
            }
          }
        },
        options: {
          id: 'writeText',
          name: 'writeText',
          desc: "writeText",
          ja: {
            name: 'テキスト',
            desc: 'テキスト描画'
          }
        }
      }
    }
  };

  PreloadItemText.getCircumPos = {
    x: function(d, r, cx) {
      return Math.cos(Math.PI / 180 * d) * r + cx;
    },
    y: function(d, r, cy) {
      return Math.sin(Math.PI / 180 * d) * r + cy;
    }
  };

  function PreloadItemText(cood) {
    if (cood == null) {
      cood = null;
    }
    PreloadItemText.__super__.constructor.call(this, cood);
    if (cood !== null) {
      this._moveLoc = {
        x: cood.x,
        y: cood.y
      };
    }
    this.inputText = null;
    this.drawHorizontal = this.constructor.WriteDirectionType.HORIZONTAL;
    this.fontFamily = 'HGP行書体';
    this.fontSize = null;
    this.isFixedFontSize = false;
    this.rowWordLength = null;
    this.showBalloon = false;
    this.balloonValue = {};
    this.balloonType = null;
    this.balloonRandomIntValue = null;
    this.textPositions = null;
    this.wordAlign = this.constructor.WordAlign.LEFT;
    this.originalItemSize = null;
    this.freeHandItemSize = null;
    this.freeHandDrawPaths = null;
    this.freeHandTextOffset = {
      top: 0,
      left: 0
    };
    this._freeHandDrawPadding = 5;
    this._fontMeatureCache = {};
    this._fixedTextAlpha = null;
    this._defaultWorkWidth = {};
  }

  PreloadItemText.prototype.itemDraw = function(show) {
    if (show == null) {
      show = true;
    }
    PreloadItemText.__super__.itemDraw.call(this, show);
    if (show) {
      if (this.inputText != null) {
        _setTextStyle.call(this);
      } else {
        _setNoTextStyle.call(this);
      }
      if (this.inputText != null) {
        return _drawTextAndBalloonToCanvas.call(this, this.inputText);
      } else {
        return _drawTextAndBalloonToCanvas.call(this, this.constructor.NO_TEXT);
      }
    }
  };

  PreloadItemText.prototype.refresh = function(show, callback) {
    if (show == null) {
      show = true;
    }
    if (callback == null) {
      callback = null;
    }
    return PreloadItemText.__super__.refresh.call(this, show, (function(_this) {
      return function() {
        _settingTextDbclickEvent.call(_this);
        if (callback != null) {
          return callback(_this);
        }
      };
    })(this));
  };

  PreloadItemText.prototype.changeInstanceVarByConfig = function(varName, value) {
    var canvas, h, height, opt, w, width;
    if (varName === 'drawHorizontal' && this.drawHorizontal !== value) {
      canvas = document.getElementById(this.canvasElementId());
      width = canvas.width;
      height = canvas.height;
      $(canvas).attr({
        width: height,
        height: width
      });
      w = this.itemSize.w;
      h = this.itemSize.h;
      this.itemSize.w = h;
      this.itemSize.h = w;
    } else if (varName === 'showBalloon' && this.showBalloon !== value && !this.isFixedFontSize) {
      canvas = document.getElementById(this.canvasElementId());
      this.showBalloon = value;
      this.fontSize = _calcFontSizeAbout.call(this, this.inputText, canvas.width, canvas.height, this.isFixedFontSize, this.drawHorizontal);
    } else if (varName === 'isFixedFontSize' || varName === 'fixedFontSize') {
      canvas = document.getElementById(this.canvasElementId());
      this[varName] = value;
      this.fontSize = _calcFontSizeAbout.call(this, this.inputText, canvas.width, canvas.height, this.isFixedFontSize, this.drawHorizontal);
    } else if (varName === 'balloonType' && (this.balloonType != null) && this.balloonType !== value) {
      if (value === this.constructor.BalloonType.FREE) {
        this.freeHandDrawPaths = null;
        opt = {
          multiDraw: true,
          applyDrawCallback: (function(_this) {
            return function(drawPaths) {
              var d, dp, idx1, idx2, k, len, len1, len2, len3, maxX, maxY, minX, minY, n, p, q;
              drawPaths = _adjustFreeHandPath.call(_this, drawPaths);
              if (drawPaths == null) {
                return false;
              }
              _this.originalItemSize = $.extend({}, _this.itemSize);
              minX = 999999;
              maxX = -1;
              minY = 999999;
              maxY = -1;
              for (k = 0, len = drawPaths.length; k < len; k++) {
                dp = drawPaths[k];
                for (n = 0, len1 = dp.length; n < len1; n++) {
                  d = dp[n];
                  if (minX > d.x) {
                    minX = d.x;
                  }
                  if (minY > d.y) {
                    minY = d.y;
                  }
                  if (maxX < d.x) {
                    maxX = d.x;
                  }
                  if (maxY < d.y) {
                    maxY = d.y;
                  }
                }
              }
              for (idx1 = p = 0, len2 = drawPaths.length; p < len2; idx1 = ++p) {
                dp = drawPaths[idx1];
                for (idx2 = q = 0, len3 = dp.length; q < len3; idx2 = ++q) {
                  d = dp[idx2];
                  drawPaths[idx1][idx2] = {
                    x: d.x - minX + _this._freeHandDrawPadding,
                    y: d.y - minY + _this._freeHandDrawPadding
                  };
                }
              }
              _this.itemSize.x = window.scrollContents.scrollLeft() + minX - _this._freeHandDrawPadding;
              _this.itemSize.y = window.scrollContents.scrollTop() + minY - _this._freeHandDrawPadding;
              _this.itemSize.w = maxX - minX + _this._freeHandDrawPadding * 2;
              _this.itemSize.h = maxY - minY + _this._freeHandDrawPadding * 2;
              _this.freeHandTextOffset.left = (_this.originalItemSize.x + _this.originalItemSize.w * 0.5) - (_this.itemSize.x + _this.itemSize.w * 0.5);
              _this.freeHandTextOffset.top = (_this.originalItemSize.y + _this.originalItemSize.h * 0.5) - (_this.itemSize.y + _this.itemSize.h * 0.5);
              _this.getJQueryElement().remove();
              _this.createItemElement(function() {
                _this.freeHandItemSize = $.extend({}, _this.itemSize);
                _this.freeHandDrawPaths = drawPaths;
                _this.saveObj();
                _this.itemDraw(true);
                if (_this.setupItemEvents != null) {
                  return _this.setupItemEvents();
                }
              });
              return true;
            };
          })(this)
        };
        EventDragPointingDraw.run(opt);
      } else {
        if (this.originalItemSize != null) {
          this.itemSize = $.extend({}, this.originalItemSize);
          this.getJQueryElement().remove();
          this.createItemElement((function(_this) {
            return function() {
              _this.saveObj();
              if (_this.setupItemEvents != null) {
                return _this.setupItemEvents();
              }
            };
          })(this));
        }
        this.freeHandTextOffset = {
          top: 0,
          left: 0
        };
      }
    }
    return PreloadItemText.__super__.changeInstanceVarByConfig.call(this, varName, value);
  };

  PreloadItemText.prototype.updateItemSize = function(w, h) {
    var canvas, element, scaleH, scaleW;
    element = $('#' + this.id);
    element.css({
      width: w,
      height: h
    });
    canvas = $('#' + this.canvasElementId());
    scaleW = element.width() / this.itemSize.w;
    scaleH = element.height() / this.itemSize.h;
    canvas.attr('width', element.width());
    canvas.attr('height', element.height());
    this.itemSize.w = w;
    this.itemSize.h = h;
    return this.refresh();
  };

  PreloadItemText.prototype.originalItemElementSize = function() {
    var obj;
    obj = PageValue.getFootprintPageValue(PageValue.Key.footprintInstanceBefore(this._event[EventPageValueBase.PageValueKey.DIST_ID], this.id));
    return obj.itemSize;
  };

  PreloadItemText.prototype.mouseUpDrawing = function(zindex, callback) {
    if (callback == null) {
      callback = null;
    }
    this.restoreAllDrawingSurface();
    _showInputModal.call(this);
    return this.endDraw(zindex, true, (function(_this) {
      return function() {
        _this.setupItemEvents();
        _this.saveObj(true);
        _this.firstFocus = Common.firstFocusItemObj() === null;
        Navbar.setModeEdit();
        WorktableCommon.changeMode(Constant.Mode.EDIT);
        if (callback != null) {
          return callback();
        }
      };
    })(this));
  };

  PreloadItemText.prototype.startOpenAnimation = function(callback) {
    if (callback == null) {
      callback = null;
    }
    this._time = 0;
    this._pertime = 1;
    this.disableHandleResponse();
    return requestAnimationFrame((function(_this) {
      return function() {
        return _startOpenAnimation.call(_this, callback);
      };
    })(this));
  };

  _startOpenAnimation = function(callback) {
    var emt, fontSize, height, progressPercent, step1, step2, step3, timemax, width, writingLength, x, y;
    if (callback == null) {
      callback = null;
    }
    if (this._canvas == null) {
      this._canvas = document.getElementById(this.canvasElementId());
      this._context = this._canvas.getContext('2d');
      this._context.save();
    }
    emt = this.getJQueryElement();
    x = null;
    y = null;
    width = null;
    height = null;
    if (this.showAnimationType === this.constructor.ShowAnimationType.POPUP) {
      timemax = 8;
      step1 = 0.6;
      step2 = 0.8;
      step3 = 1;
      if (this._time / timemax <= step1) {
        progressPercent = this._time / (timemax * step1);
        x = (this.itemSize.w * 0.5) + (((this.itemSize.w - this.itemSize.w * 0.9) * 0.5) - (this.itemSize.w * 0.5)) * progressPercent;
        y = (this.itemSize.h * 0.5) + (((this.itemSize.h - this.itemSize.h * 0.9) * 0.5) - (this.itemSize.h * 0.5)) * progressPercent;
        width = (this.itemSize.w * 0.9) * progressPercent;
        height = (this.itemSize.h * 0.9) * progressPercent;
        this._step1 = {
          x: x,
          y: y,
          w: width,
          h: height
        };
        this._time1 = this._time;
      } else if (this._time / timemax <= step2) {
        progressPercent = (this._time - this._time1) / (timemax * (step2 - step1));
        x = this._step1.x + (((this.itemSize.w - this.itemSize.w * 0.6) * 0.5) - this._step1.x) * progressPercent;
        y = this._step1.y + (((this.itemSize.h - this.itemSize.h * 0.6) * 0.5) - this._step1.y) * progressPercent;
        width = this._step1.w + (this.itemSize.w * 0.6 - this._step1.w) * progressPercent;
        height = this._step1.h + (this.itemSize.h * 0.6 - this._step1.h) * progressPercent;
        this._step2 = {
          x: x,
          y: y,
          w: width,
          h: height
        };
        this._time2 = this._time;
      } else if (this._time / timemax <= step3) {
        progressPercent = (this._time - this._time2) / (timemax * (step3 - step2));
        if (progressPercent > 1) {
          progressPercent = 1;
        }
        x = this._step2.x - this._step2.x * progressPercent;
        y = this._step2.y - this._step2.y * progressPercent;
        width = this._step2.w + (this.itemSize.w - this._step2.w) * progressPercent;
        height = this._step2.h + (this.itemSize.h - this._step2.h) * progressPercent;
      }
      fontSize = _calcFontSizeAbout.call(this, this.inputText, width, height, this.isFixedFontSize, this.drawHorizontal);
    } else if (this.showAnimationType === this.constructor.ShowAnimationType.FADE) {
      timemax = 30;
      step1 = 1;
      fontSize = this.fontSize;
      x = 0;
      y = 0;
      width = this._canvas.width;
      height = this._canvas.height;
      if (this._time / timemax <= step1) {
        progressPercent = this._time / (timemax * step1);
        this._fixedBalloonAlpha = progressPercent;
      }
    }
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    _drawBalloon.call(this, this._context, x, y, width, height, this._canvas.width, this._canvas.height);
    writingLength = this.getEventMethodName() === 'changeText' ? this.inputText.length : 0;
    _drawText.call(this, this._context, this.inputText, x, y, width, height, fontSize, writingLength);
    this._time += this._pertime;
    if (this._time <= timemax) {
      return requestAnimationFrame((function(_this) {
        return function() {
          return _startOpenAnimation.call(_this, callback);
        };
      })(this));
    } else {
      this._context.restore();
      this.enableHandleResponse();
      if (callback != null) {
        return callback();
      }
    }
  };

  PreloadItemText.prototype.startCloseAnimation = function(callback) {
    if (callback == null) {
      callback = null;
    }
    this._time = 0;
    this._pertime = 1;
    this.disableHandleResponse();
    return requestAnimationFrame((function(_this) {
      return function() {
        return _startCloseAnimation.call(_this, callback);
      };
    })(this));
  };

  _startCloseAnimation = function(callback) {
    var canvas, context, emt, fontSize, height, progressPercent, step1, step2, step3, timemax, width, x, y;
    if (callback == null) {
      callback = null;
    }
    if (this._canvas == null) {
      this._canvas = document.getElementById(this.canvasElementId());
      this._context = this._canvas.getContext('2d');
      this._context.save();
    }
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    emt = this.getJQueryElement();
    x = null;
    y = null;
    width = null;
    height = null;
    fontSize = null;
    if (this.showAnimationType === this.constructor.ShowAnimationType.POPUP) {
      timemax = 8;
      step1 = 0.2;
      step2 = 0.5;
      step3 = 1;
      if (this._time / timemax <= step1) {
        progressPercent = this._time / (timemax * step1);
        x = (this.itemSize.w - this.itemSize.w * 0.5) * 0.5 * progressPercent;
        y = (this.itemSize.h - this.itemSize.h * 0.5) * 0.5 * progressPercent;
        width = this.itemSize.w + (this.itemSize.w * 0.5 - this.itemSize.w) * progressPercent;
        height = this.itemSize.h + (this.itemSize.h * 0.5 - this.itemSize.h) * progressPercent;
        this._step1 = {
          x: x,
          y: y,
          w: width,
          h: height
        };
        this._time1 = this._time;
      } else if (this._time / timemax <= step2) {
        progressPercent = (this._time - this._time1) / (timemax * (step2 - step1));
        x = this._step1.x + (((this.itemSize.w - this.itemSize.w * 0.9) * 0.5) - this._step1.x) * progressPercent;
        y = this._step1.y + (((this.itemSize.h - this.itemSize.h * 0.9) * 0.5) - this._step1.y) * progressPercent;
        width = this._step1.w + (this.itemSize.w * 0.9 - this._step1.w) * progressPercent;
        height = this._step1.h + (this.itemSize.h * 0.9 - this._step1.h) * progressPercent;
        this._step2 = {
          x: x,
          y: y,
          w: width,
          h: height
        };
        this._time2 = this._time;
      } else if (this._time / timemax <= step3) {
        progressPercent = (this._time - this._time2) / (timemax * (step3 - step2));
        if (progressPercent > 1) {
          progressPercent = 1;
        }
        x = this._step2.x + (this.itemSize.w * 0.5 - this._step2.x) * progressPercent;
        y = this._step2.y + (this.itemSize.h * 0.5 - this._step2.y) * progressPercent;
        width = this._step2.w - this._step2.w * progressPercent;
        height = this._step2.h - this._step2.h * progressPercent;
      }
      fontSize = _calcFontSizeAbout.call(this, this.inputText, width, height, this.isFixedFontSize, this.drawHorizontal);
    } else if (this.showAnimationType === this.constructor.ShowAnimationType.FADE) {
      timemax = 30;
      step1 = 1;
      fontSize = this.fontSize;
      x = 0;
      y = 0;
      width = this._canvas.width;
      height = this._canvas.height;
      if (this._time / timemax <= step1) {
        progressPercent = 1 - (this._time / (timemax * step1));
        this._fixedBalloonAlpha = progressPercent;
        this._fixedTextAlpha = progressPercent;
      }
    }
    _drawBalloon.call(this, this._context, x, y, width, height, this._canvas.width, this._canvas.height);
    _drawText.call(this, this._context, this.inputText, x, y, width, height, fontSize, this.inputText.length);
    this._time += this._pertime;
    if (this._time <= timemax) {
      return requestAnimationFrame((function(_this) {
        return function() {
          return _startCloseAnimation.call(_this, callback);
        };
      })(this));
    } else {
      this._context.restore();
      canvas = document.getElementById(this.canvasElementId());
      context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);
      this.enableHandleResponse();
      if (!this._isFinishedEvent) {
        this.finishEvent();
        if (typeof ScrollGuide !== "undefined" && ScrollGuide !== null) {
          ScrollGuide.hideGuide();
        }
      }
      if (callback != null) {
        return callback();
      }
    }
  };

  PreloadItemText.prototype.willChapter = function() {
    this._animationFlg = {};
    return PreloadItemText.__super__.willChapter.call(this);
  };

  PreloadItemText.isJapanease = function(c) {
    return c.charCodeAt(0) >= 256;
  };

  PreloadItemText.prototype.changeText = function(opt) {
    var canvas, context, opa;
    this.showWithAnimation = this.showWithAnimation__after;
    this.showAnimationType = this.showAnimationType__after;
    this.showAnimationType;
    if (this.showWithAnimation && (this._animationFlg['startOpenAnimation'] == null)) {
      this.startOpenAnimation((function(_this) {
        return function() {
          return _this.changeText(opt);
        };
      })(this));
      this._animationFlg['startOpenAnimation'] = true;
    } else {
      opa = opt.progress / opt.progressMax;
      canvas = document.getElementById(this.canvasElementId());
      context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = "rgb(" + this.textColor.r + "," + this.textColor.g + "," + this.textColor.b + ")";
      this._fixedTextAlpha = 1 - opa;
      _drawTextAndBalloonToCanvas.call(this, this.inputText__before);
      this._fixedTextAlpha = opa;
      _drawTextAndBalloonToCanvas.call(this, this.inputText__after);
    }
    if (opt.progress === opt.progressMax && this.showWithAnimation && (this._animationFlg['startCloseAnimation'] == null)) {
      this.startCloseAnimation();
      return this._animationFlg['startCloseAnimation'] = true;
    }
  };

  PreloadItemText.prototype.writeText = function(opt) {
    var _write, adjustProgress, writeBlurLength, writeLength;
    this.showWithAnimation = this.showWithAnimation__after;
    this.showAnimationType = this.showAnimationType__after;
    this._forward = opt.forward;
    if (this.showWithAnimation && (this._animationFlg['startOpenAnimation'] == null)) {
      this.startOpenAnimation((function(_this) {
        return function() {
          _this._animationFlg['startOpenAnimation'] = true;
          return _this.resetProgress();
        };
      })(this));
    } else {
      if (opt.progress < opt.progressMax && (this.inputText != null) && this.inputText.length > 0) {
        if ((this._writeTextRunning == null) || !this._writeTextRunning) {
          this._fixedTextAlpha = null;
          adjustProgress = opt.progressMax / this.inputText.length;
          writeLength = this.inputText.length * (opt.progress + adjustProgress * 0.5) / opt.progressMax;
          if (this._beforeWriteLength == null) {
            this._beforeWriteLength = 0;
          }
          writeBlurLength = parseInt(writeLength) - parseInt(this._beforeWriteLength);
          if (Math.abs(writeBlurLength) > 0) {
            this._writeTextRunning = true;
            this._beforeWriteLength = writeLength;
            this._writeBlurLength = Math.abs(writeBlurLength);
            this._alphaDiff = 0;
            _write = function() {
              _setTextStyle.call(this);
              _drawTextAndBalloonToCanvas.call(this, this.inputText, writeLength);
              this._alphaDiff += this._writeBlurLength / 5;
              if (this._alphaDiff <= this._writeBlurLength) {
                if (this._writeTextTimer != null) {
                  clearTimeout(this._writeTextTimer);
                  this._writeTextTimer = null;
                }
                return this._writeTextTimer = setTimeout((function(_this) {
                  return function() {
                    return requestAnimationFrame(function() {
                      if (_this._animationFlg['startCloseAnimation'] == null) {
                        return _write.call(_this);
                      }
                    });
                  };
                })(this), 10);
              } else {
                return this._writeTextRunning = false;
              }
            };
            requestAnimationFrame((function(_this) {
              return function() {
                return _write.call(_this);
              };
            })(this));
          }
        }
      }
    }
    if (opt.progress >= opt.progressMax && this.showWithAnimation && (this._animationFlg['startCloseAnimation'] == null)) {
      if (this._writeTextTimer != null) {
        clearTimeout(this._writeTextTimer);
        this._writeTextTimer = null;
      }
      this._writeTextRunning = false;
      this.startCloseAnimation();
      return this._animationFlg['startCloseAnimation'] = true;
    }
  };

  _setTextStyle = function() {
    var canvas, context;
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    return context.fillStyle = "rgb(" + this.textColor.r + "," + this.textColor.g + "," + this.textColor.b + ")";
  };

  _setNoTextStyle = function() {
    var canvas, context;
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    return context.fillStyle = "rgba(" + this.textColor.r + "," + this.textColor.g + "," + this.textColor.b + ", 0.3)";
  };

  _drawTextAndBalloonToCanvas = function(text, writingLength) {
    var canvas, context;
    if (writingLength == null) {
      writingLength = text.length;
    }
    if (text == null) {
      return;
    }
    canvas = document.getElementById(this.canvasElementId());
    context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
    _drawBalloon.call(this, context, 0, 0, canvas.width, canvas.height);
    if (this.fontSize == null) {
      this.fontSize = _calcFontSizeAbout.call(this, text, canvas.width, canvas.height, this.isFixedFontSize, this.drawHorizontal);
    }
    return _drawText.call(this, context, text, 0, 0, canvas.width, canvas.height, this.fontSize, writingLength);
  };

  _getRandomInt = function(max, min) {
    return Math.floor(Math.random() * (max - min)) + min;
  };

  _drawBalloon = function(context, x, y, width, height, canvasWidth, canvasHeight) {
    var _balloonStyle, _drawArc, _drawBArc, _drawBRect, _drawFreeHand, _drawRect, _drawShout, _drawThink;
    if (canvasWidth == null) {
      canvasWidth = width;
    }
    if (canvasHeight == null) {
      canvasHeight = height;
    }
    if (!this.showBalloon) {
      return;
    }
    if (width <= 0 || height <= 0) {
      return;
    }
    if ((this._drawBalloonPathCacle != null) && (this._drawBalloonPathCacle[x] != null) && (this._drawBalloonPathCacle[x][y] != null) && (this._drawBalloonPathCacle[x][y][width] != null) && (this._drawBalloonPathCacle[x][y][width][height] != null) && this._drawBalloonPathCacle[x][y][width][height][this.balloonType]) {
      context.putImageData(this._drawBalloonPathCacle[x][y][width][height][this.balloonType], 0, 0);
      return;
    }
    _balloonStyle = function(context) {
      context.fillStyle = "rgba(" + this.balloonColor.r + "," + this.balloonColor.g + "," + this.balloonColor.b + ", 0.95)";
      context.strokeStyle = "rgba(" + this.balloonBorderColor.r + "," + this.balloonBorderColor.g + "," + this.balloonBorderColor.b + ", 0.95)";
      context.shadowColor = 'rgba(0,0,0,0.3)';
      context.shadowOffsetX = 3;
      context.shadowOffsetY = 3;
      return context.shadowBlur = 4;
    };
    _drawArc = function() {
      var diff, r;
      context.beginPath();
      context.translate(canvasWidth * 0.5, canvasHeight * 0.5);
      diff = 10.0;
      if (width > height) {
        context.scale(canvasWidth / canvasHeight, 1);
        r = height * 0.5 - diff;
        if (r < 0) {
          r = 0;
        }
        context.arc(0, 0, r, 0, Math.PI * 2);
      } else {
        context.scale(1, canvasHeight / canvasWidth);
        r = width * 0.5 - diff;
        if (r < 0) {
          r = 0;
        }
        context.arc(0, 0, r, 0, Math.PI * 2);
      }
      context.fill();
      return context.stroke();
    };
    _drawRect = function() {
      context.beginPath();
      return context.fillRect(x, y, width, height);
    };
    _drawBArc = function() {
      var diff, l, per, r, results, results1, sum;
      diff = 10.0;
      context.translate(canvasWidth * 0.5, canvasHeight * 0.5);
      per = Math.PI * 2 / 100;
      if (width > height) {
        context.scale(canvasWidth / canvasHeight, 1);
        sum = 0;
        x = 0;
        results = [];
        while (sum < Math.PI * 2) {
          context.beginPath();
          l = ((2 * Math.abs(Math.cos(x))) + 1) * per;
          y = x + l;
          r = height * 0.5 - diff;
          if (r < 0) {
            r = 0;
          }
          context.arc(0, 0, r, x, y);
          context.fill();
          context.stroke();
          sum += l;
          x = y;
          l = ((1 * Math.abs(Math.cos(x))) + 1) * per;
          y = x + l;
          sum += l;
          results.push(x = y);
        }
        return results;
      } else {
        context.scale(1, canvasHeight / canvasWidth);
        sum = 0;
        x = 0;
        results1 = [];
        while (sum < Math.PI * 2) {
          context.beginPath();
          l = ((2 * Math.abs(Math.sin(x))) + 1) * per;
          y = x + l;
          r = width * 0.5 - diff;
          if (r < 0) {
            r = 0;
          }
          context.arc(0, 0, r, x, y);
          context.fill();
          context.stroke();
          sum += l;
          x = y;
          l = ((1 * Math.abs(Math.sin(x))) + 1) * per;
          y = x + l;
          sum += l;
          results1.push(x = y);
        }
        return results1;
      }
    };
    _drawBRect = function() {
      var _draw, dashLength;
      dashLength = 5;
      context.beginPath();
      _draw = function(sx, sy, ex, ey) {
        var deltaX, deltaY, i, k, numDashes, ref, results;
        deltaX = ex - sx;
        deltaY = ey - sy;
        numDashes = Math.floor(Math.sqrt(deltaX * deltaX + deltaY * deltaY) / dashLength);
        results = [];
        for (i = k = 0, ref = numDashes - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          if (i % 2 === 0) {
            results.push(context.moveTo(sx + (deltaX / numDashes) * i, sy + (deltaY / numDashes) * i));
          } else {
            results.push(context.lineTo(sx + (deltaX / numDashes) * i, sy + (deltaY / numDashes) * i));
          }
        }
        return results;
      };
      _draw.call(this, x, y, width, y);
      _draw.call(this, width, y, width, height);
      _draw.call(this, width, height, x, height);
      _draw.call(this, x, height, x, y);
      context.fillRect(x, y, width, height);
      return context.stroke();
    };
    _drawShout = (function(_this) {
      return function() {
        var addDeg, beginX, beginY, cp1x, cp1y, cp2x, cp2y, cx, cy, deg, endX, endY, i, k, num, punkLineMax, punkLineMin, radiusX, radiusY, random, ref, s;
        num = 18;
        radiusX = width / 2;
        radiusY = height / 2;
        cx = x + width / 2;
        cy = y + height / 2;
        if (_this.drawHorizontal) {
          s = _this.itemSize.h;
        } else {
          s = _this.itemSize.w;
        }
        punkLineMax = s * 0.2;
        punkLineMin = s * 0.1;
        deg = 0;
        addDeg = 360 / num;
        context.beginPath();
        context.lineJoin = 'round';
        context.lineCap = 'round';
        if (_this.balloonRandomIntValue == null) {
          _this.balloonRandomIntValue = _getRandomInt.call(_this, punkLineMax, punkLineMin);
        }
        for (i = k = 0, ref = num - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          deg += addDeg;
          random = _this.balloonRandomIntValue;
          beginX = PreloadItemText.getCircumPos.x(deg, radiusX, cx);
          beginY = PreloadItemText.getCircumPos.y(deg, radiusY, cy);
          endX = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX, cx);
          endY = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY, cy);
          cp1x = PreloadItemText.getCircumPos.x(deg, radiusX - random * 0.6, cx);
          cp1y = PreloadItemText.getCircumPos.y(deg, radiusY - random * 0.6, cy);
          cp2x = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX - random * 0.6, cx);
          cp2y = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY - random * 0.6, cy);
          if (i === 0) {
            context.moveTo(beginX, beginY);
            context.arcTo(beginX, beginY, endX, endY, punkLineMax);
          }
          context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
        }
        context.fill();
        return context.stroke();
      };
    })(this);
    _drawThink = (function(_this) {
      return function() {
        var addDeg, beginX, beginY, cp1x, cp1y, cp2x, cp2y, cx, cy, deg, diff, endX, endY, i, k, num, punkLineMax, punkLineMin, radiusX, radiusY, random, ref, s;
        num = 8;
        cx = x + width / 2;
        cy = y + height / 2;
        if (_this.drawHorizontal) {
          s = _this.itemSize.h;
        } else {
          s = _this.itemSize.w;
        }
        punkLineMax = s * 0.3;
        punkLineMin = s * 0.1;
        diff = punkLineMin + (punkLineMax - punkLineMin) * 0.6;
        radiusX = (width - diff) / 2;
        radiusY = (height - diff) / 2;
        deg = 0;
        addDeg = 360 / num;
        context.beginPath();
        context.lineJoin = 'round';
        context.lineCap = 'round';
        if (_this.balloonRandomIntValue == null) {
          _this.balloonRandomIntValue = _getRandomInt.call(_this, punkLineMax, punkLineMin);
        }
        for (i = k = 0, ref = num - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          deg += addDeg;
          random = _this.balloonRandomIntValue;
          beginX = PreloadItemText.getCircumPos.x(deg, radiusX, cx);
          beginY = PreloadItemText.getCircumPos.y(deg, radiusY, cy);
          endX = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX, cx);
          endY = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY, cy);
          cp1x = PreloadItemText.getCircumPos.x(deg, radiusX + random * 0.7, cx);
          cp1y = PreloadItemText.getCircumPos.y(deg, radiusY + random * 0.7, cy);
          cp2x = PreloadItemText.getCircumPos.x(deg + addDeg, radiusX + random * 0.7, cx);
          cp2y = PreloadItemText.getCircumPos.y(deg + addDeg, radiusY + random * 0.7, cy);
          if (i === 0) {
            context.moveTo(beginX, beginY);
            context.arcTo(beginX, beginY, endX, endY, punkLineMax);
          }
          context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
        }
        context.fill();
        return context.stroke();
      };
    })(this);
    _drawFreeHand = (function(_this) {
      return function() {
        if (_this.freeHandDrawPaths != null) {
          return _freeHandBalloonDraw.call(_this, context, x, y, width, height, canvasWidth, canvasHeight, _this.freeHandDrawPaths);
        }
      };
    })(this);
    context.save();
    context.globalAlpha = this._fixedBalloonAlpha != null ? this._fixedBalloonAlpha : 1;
    _balloonStyle.call(this, context);
    if (this.balloonType === this.constructor.BalloonType.ARC) {
      _drawArc.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.RECT) {
      _drawRect.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.BROKEN_ARC) {
      _drawBArc.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.BROKEN_RECT) {
      _drawBRect.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.FLASH) {
      _drawShout.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.CLOUD) {
      _drawThink.call(this);
    } else if (this.balloonType === this.constructor.BalloonType.FREE) {
      _drawFreeHand.call(this);
    }
    if (this._drawBalloonPathCacle == null) {
      this._drawBalloonPathCacle = {};
    }
    if (this._drawBalloonPathCacle[x] == null) {
      this._drawBalloonPathCacle[x] = {};
    }
    if (this._drawBalloonPathCacle[x][y] == null) {
      this._drawBalloonPathCacle[x][y] = {};
    }
    if (this._drawBalloonPathCacle[x][y][width] == null) {
      this._drawBalloonPathCacle[x][y][width] = {};
    }
    if (this._drawBalloonPathCacle[x][y][width][height] == null) {
      this._drawBalloonPathCacle[x][y][width][height] = {};
    }
    this._drawBalloonPathCacle[x][y][width][height][this.balloonType] = context.getImageData(0, 0, width, height);
    return context.restore();
  };

  _adjustFreeHandPath = function(drawPaths) {
    var _search, i, retArray, searchedIndex;
    i = drawPaths.length - 1;
    while (i >= 0) {
      if (drawPaths[i].length === 0) {
        drawPaths.splice(i, 1);
      }
      i -= 1;
    }
    retArray = [drawPaths[0]];
    searchedIndex = [0];
    _search = function(targetIndex, isTail) {
      var a, dp, idx, it, j, k, len, len1, m, mLen, n, ref, searchTarget, sq, targetCood;
      searchTarget = drawPaths[targetIndex];
      targetCood = isTail ? searchTarget[searchTarget.length - 1] : searchTarget[0];
      mLen = 999999;
      m = null;
      i = null;
      it = null;
      for (idx = k = 0, len = drawPaths.length; k < len; idx = ++k) {
        dp = drawPaths[idx];
        ref = [0, dp.length - 1];
        for (n = 0, len1 = ref.length; n < len1; n++) {
          j = ref[n];
          if (searchedIndex.indexOf(idx) < 0) {
            sq = Math.pow(dp[j].x - targetCood.x, 2) + Math.pow(dp[j].y - targetCood.y, 2);
            if (sq < mLen) {
              mLen = sq;
              m = {
                x: dp[j].x,
                y: dp[j].y
              };
              it = j !== 0;
              i = idx;
            }
          }
        }
      }
      if (m != null) {
        a = drawPaths[i].concat();
        if (it) {
          a = a.reverse();
        }
        searchedIndex.push(i);
        retArray.push([targetCood, m]);
        retArray.push(a);
        return _search.call(this, i, !it);
      }
    };
    _search(0, true);
    return retArray;
  };

  _freeHandBalloonDraw = function(context, x, y, width, height, canvasWidth, canvasHeight, drawPaths) {
    var cx, cy, d, dp, dx, dy, i1, i2, idx1, idx2, k, len, len1, len2, len3, modDP, n, p, percent, q;
    cx = canvasWidth * 0.5;
    cy = canvasHeight * 0.5;
    percent = width / canvasWidth;
    modDP = [];
    for (i1 = k = 0, len = drawPaths.length; k < len; i1 = ++k) {
      dp = drawPaths[i1];
      modDP[i1] = [];
      for (i2 = n = 0, len1 = dp.length; n < len1; i2 = ++n) {
        d = dp[i2];
        modDP[i1][i2] = {
          x: cx - (cx - d.x) * percent,
          y: cy - (cy - d.y) * percent
        };
      }
    }
    context.beginPath();
    for (idx1 = p = 0, len2 = modDP.length; p < len2; idx1 = ++p) {
      dp = modDP[idx1];
      for (idx2 = q = 0, len3 = dp.length; q < len3; idx2 = ++q) {
        d = dp[idx2];
        dx = d.x;
        dy = d.y;
        if (idx1 === 0 && idx2 === 0) {
          context.moveTo(dx, dy);
        } else {
          context.lineTo(dx, dy);
        }
      }
    }
    context.closePath();
    context.lineJoin = 'round';
    context.lineCap = 'round';
    context.fill();
    return context.stroke();
  };

  _calcHorizontalColumnWidth = function(context, columnText) {
    var char, k, len, ref, sum;
    sum = 0;
    ref = columnText.split('');
    for (k = 0, len = ref.length; k < len; k++) {
      char = ref[k];
      sum += context.measureText(char).width;
    }
    return sum;
  };

  _calcHorizontalColumnWidthMax = function(context, columns) {
    var c, k, len, r, ret;
    ret = 0;
    for (k = 0, len = columns.length; k < len; k++) {
      c = columns[k];
      r = _calcHorizontalColumnWidth.call(this, context, c);
      if (ret < r) {
        ret = r;
      }
    }
    return ret;
  };

  _calcVerticalColumnHeight = function(columnText, fontSize) {
    var c, k, len, measure, ref, ret;
    ret = 0;
    ref = columnText.split('');
    for (k = 0, len = ref.length; k < len; k++) {
      c = ref[k];
      measure = _calcWordMeasure.call(this, c, fontSize, this.fontFamily);
      if (PreloadItemText.isJapanease(c)) {
        ret += _defaultWorkWidth.call(this, fontSize, this.fontFamily);
      } else {
        ret += measure.height;
      }
    }
    return ret;
  };

  _calcHorizontalColumnHeightMax = function(columnText, fontSize) {
    var c, k, len, measure, r, ref, ret;
    ret = 0;
    ref = columnText.split('');
    for (k = 0, len = ref.length; k < len; k++) {
      c = ref[k];
      measure = _calcWordMeasure.call(this, c, fontSize, this.fontFamily);
      r = measure.height;
      if (ret < r) {
        ret = r;
      }
    }
    return ret;
  };

  _calcHorizontalColumnHeightSum = function(columns, fontSize) {
    var c, k, len, sum;
    sum = 0;
    for (k = 0, len = columns.length; k < len; k++) {
      c = columns[k];
      sum += _calcHorizontalColumnHeightMax.call(this, c, fontSize);
    }
    return sum;
  };

  _calcVerticalColumnHeightMax = function(columns, fontSize) {
    var c, k, len, r, ret;
    ret = 0;
    for (k = 0, len = columns.length; k < len; k++) {
      c = columns[k];
      r = _calcVerticalColumnHeight.call(this, c, fontSize);
      if (ret < r) {
        ret = r;
      }
    }
    return ret;
  };

  _setTextAlpha = function(context, idx, writingLength) {
    var ga, methodName;
    methodName = this.getEventMethodName();
    if (methodName === 'changeText') {
      if (this._fixedTextAlpha != null) {
        return context.globalAlpha = this._fixedTextAlpha;
      }
    } else if (methodName === 'writeText') {
      if (this._forward) {
        ga = null;
        if (writingLength === 0 || idx > writingLength) {
          ga = 0;
        } else if (idx <= writingLength - this._writeBlurLength) {
          ga = 1;
        } else {
          ga = this._alphaDiff / this._writeBlurLength + ((writingLength - idx) / this._writeBlurLength);
          if (ga < 0) {
            ga = 0;
          }
          if (ga > 1) {
            ga = 1;
          }
        }
        return context.globalAlpha = ga;
      } else {
        ga = null;
        if (writingLength === 0 || idx > writingLength + this._writeBlurLength) {
          ga = 0;
        } else if (idx <= writingLength) {
          ga = 1;
        } else {
          ga = 1 - (this._alphaDiff / this._writeBlurLength + ((idx - writingLength) / this._writeBlurLength));
          if (ga < 0) {
            ga = 0;
          }
          if (ga > 1) {
            ga = 1;
          }
        }
        return context.globalAlpha = ga;
      }
    }
  };

  _writeLength = function(column, writingLength, wordSum) {
    var v;
    v = parseInt(writingLength - wordSum);
    if (v > column.length) {
      v = column.length;
    } else if (v < 0) {
      v = 0;
    }
    return v;
  };

  _drawText = function(context, text, x, y, width, height, fontSize, writingLength) {
    var c, char, column, engDiff, h, heightDiff, heightLine, heightMax, hl, i, idx, j, k, len, len1, line, measure, n, p, q, ref, ref1, ref2, ref3, ref4, sizeSum, t, w, widthLine, widthMax, wl, wordSum, wordWidth, ww;
    if (writingLength == null) {
      writingLength = text.length;
    }
    context.save();
    context.font = fontSize + "px " + this.fontFamily;
    wordWidth = _defaultWorkWidth.call(this, fontSize, this.fontFamily);
    column = [''];
    line = 0;
    text = text.replace("{br}", "\n", "gm");
    for (i = k = 0, ref = text.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      char = text.charAt(i);
      if (((this.rowWordLength != null) && this.rowWordLength <= column[line].length) || char === "\n") {
        line += 1;
        column[line] = '';
        if (char === "\n") {
          char = '';
        }
      }
      column[line] += char;
    }
    sizeSum = 0;
    wordSum = 0;
    if (this.drawHorizontal === this.constructor.WriteDirectionType.HORIZONTAL) {
      heightLine = y + (height - _calcHorizontalColumnHeightSum.call(this, column, fontSize)) * 0.5;
      widthMax = _calcHorizontalColumnWidthMax.call(this, context, column);
      if (this.balloonType === this.constructor.BalloonType.FREE) {
        x += this.freeHandTextOffset.left;
        heightLine += this.freeHandTextOffset.top;
      }
      for (j = n = 0, ref1 = column.length - 1; 0 <= ref1 ? n <= ref1 : n >= ref1; j = 0 <= ref1 ? ++n : --n) {
        heightLine += _calcHorizontalColumnHeightMax.call(this, column[j], fontSize);
        w = x;
        if (this.wordAlign === this.constructor.WordAlign.LEFT) {
          w += (width - widthMax) * 0.5;
        } else if (this.wordAlign === this.constructor.WordAlign.CENTER) {
          w += (width - _calcHorizontalColumnWidth.call(this, context, column[j])) * 0.5;
        } else {
          w += (width + widthMax) * 0.5 - _calcHorizontalColumnWidth.call(this, context, column[j]);
        }
        context.beginPath();
        wl = 0;
        ref2 = column[j].split('');
        for (idx = p = 0, len = ref2.length; p < len; idx = ++p) {
          c = ref2[idx];
          _setTextAlpha.call(this, context, idx + wordSum + 1, writingLength);
          context.fillText(c, w + wl, heightLine);
          wl += context.measureText(c).width;
        }
        wordSum += column[j].length;
      }
    } else {
      widthLine = x + (width + wordWidth * column.length) * 0.5;
      heightMax = _calcVerticalColumnHeightMax.call(this, column, fontSize);
      if (this.balloonType === this.constructor.BalloonType.FREE) {
        widthLine += this.freeHandTextOffset.left;
        y += this.freeHandTextOffset.top;
      }
      for (j = q = 0, ref3 = column.length - 1; 0 <= ref3 ? q <= ref3 : q >= ref3; j = 0 <= ref3 ? ++q : --q) {
        widthLine -= wordWidth;
        h = y;
        if (this.wordAlign === this.constructor.WordAlign.LEFT) {
          h += (height - heightMax) * 0.5;
        } else if (this.wordAlign === this.constructor.WordAlign.CENTER) {
          h += (height - _calcVerticalColumnHeight.call(this, column[j], fontSize)) * 0.5;
        } else {
          h += (height + heightMax) * 0.5 - _calcVerticalColumnHeight.call(this, column[j], fontSize);
        }
        context.beginPath();
        hl = 0;
        ref4 = column[j].split('');
        for (idx = t = 0, len1 = ref4.length; t < len1; idx = ++t) {
          c = ref4[idx];
          measure = _calcWordMeasure.call(this, c, fontSize, this.fontFamily);
          _setTextAlpha.call(this, context, idx + wordSum + 1, writingLength);
          if (PreloadItemText.isJapanease(c)) {
            hl += wordWidth;
          } else {
            hl += measure.height;
          }
          if (_isWordSmallJapanease.call(this, c)) {
            heightDiff = wordWidth * 0.1;
            context.fillText(c, widthLine + (wordWidth - measure.width) * 0.5, h + hl - heightDiff);
          } else if (_isWordNeedRotate.call(this, c)) {
            context.save();
            context.beginPath();
            if (PreloadItemText.isJapanease(c)) {
              ww = wordWidth;
            } else {
              ww = measure.height;
            }
            context.translate(widthLine + wordWidth * 0.5, h + hl - ww * 0.5);
            context.rotate(Math.PI / 2);
            engDiff = wordWidth - ww;
            context.fillText(c, -measure.width * 0.5, wordWidth * 0.75 * 0.5 - engDiff * 0.5);
            context.restore();
          } else {
            context.fillText(c, widthLine, h + hl);
          }
        }
        wordSum += column[j].length;
      }
    }
    return context.restore();
  };

  _calcWordMeasure = function(char, fontSize, fontFamily) {
    var fontSizeKey, mi, nCanvas, nContext, writedImage;
    fontSizeKey = "" + fontSize;
    if ((this._fontMeatureCache[fontSizeKey] != null) && (this._fontMeatureCache[fontSizeKey][fontFamily] != null) && (this._fontMeatureCache[fontSizeKey][fontFamily][char] != null)) {
      return this._fontMeatureCache[fontSizeKey][fontFamily][char];
    }
    nCanvas = document.createElement('canvas');
    nCanvas.width = 500;
    nCanvas.height = 500;
    nContext = nCanvas.getContext('2d');
    nContext.font = fontSize + "px " + fontFamily;
    nContext.textBaseline = 'top';
    nContext.fillStyle = nCanvas.strokeStyle = '#ff0000';
    nContext.fillText(char, 0, 0);
    writedImage = nContext.getImageData(0, 0, nCanvas.width, nCanvas.height);
    mi = _measureImage.call(this, writedImage);
    if (this._fontMeatureCache[fontSizeKey] == null) {
      this._fontMeatureCache[fontSizeKey] = {};
    }
    if (this._fontMeatureCache[fontSizeKey][fontFamily] == null) {
      this._fontMeatureCache[fontSizeKey][fontFamily] = {};
    }
    this._fontMeatureCache[fontSizeKey][fontFamily][char] = mi;
    return mi;
  };

  _measureImage = function(_writedImage) {
    var i, k, maxX, maxY, minX, minY, ref, w, x, y;
    w = _writedImage.width;
    x = 0;
    y = 0;
    minX = 9999;
    maxX = 0;
    minY = 9999;
    maxY = 0;
    for (i = k = 0, ref = _writedImage.data.length - 1; k <= ref; i = k += 4) {
      if (_writedImage.data[i + 0] > 128) {
        if (x < minX) {
          minX = x;
        }
        if (x > maxX) {
          maxX = x;
        }
        if (y < minY) {
          minY = y;
        }
        if (y > maxY) {
          maxY = y;
        }
      }
      x += 1;
      if (x >= w) {
        x = 0;
        y += 1;
      }
    }
    return {
      width: maxX - minX + 1,
      height: maxY - minY + 1
    };
  };

  _isWordSmallJapanease = function(char) {
    var list, regex;
    list = '、。ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ'.split('');
    list = list.concat([',', '\\.']);
    regex = new RegExp(list.join('|'));
    return char.match(regex);
  };

  _isWordNeedRotate = function(char) {
    var list, regex;
    if (!PreloadItemText.isJapanease(char)) {
      return true;
    }
    list = 'ー＝〜・';
    regex = new RegExp(list.split('').join('|'));
    return char.match(regex);
  };

  _calcFontSizeAbout = function(text, width, height, isFixedFontSize, drawHorizontal) {
    var a, fontSize, h, newLineCount, w;
    if (width <= 0 || height <= 0) {
      return;
    }
    if (this.inputText == null) {
      return 12;
    }
    a = text.length;
    text = text.replace(/\n+$/g, '');
    if (!isFixedFontSize) {
      newLineCount = text.split('\n').length - 1;
      if (drawHorizontal === this.constructor.WriteDirectionType.HORIZONTAL) {
        w = height;
        h = width;
      } else {
        w = width;
        h = height;
      }
      fontSize = (Math.sqrt(Math.pow(newLineCount, 2) + (w * 4 * (a + 1)) / h) - newLineCount) * h / ((a + 1) * 2);
      fontSize = parseInt(fontSize / 1.8);
      if (fontSize < 1) {
        fontSize = 1;
      }
      if (this.showBalloon && fontSize >= 6) {
        fontSize -= 5;
      }
      return fontSize;
    } else {
      return this.fixedFontSize;
    }
  };

  _showInputModal = function() {
    return Common.showModalView(Constant.ModalViewType.ITEM_TEXT_EDITING, false, (function(_this) {
      return function(modalEmt, params, callback) {
        if (callback == null) {
          callback = null;
        }
        _prepareEditModal.call(_this, modalEmt);
        if (callback != null) {
          return callback();
        }
      };
    })(this));
  };

  _settingTextDbclickEvent = function() {
    return this.getJQueryElement().off('dblclick').on('dblclick', (function(_this) {
      return function(e) {
        e.preventDefault();
        return _showInputModal.call(_this);
      };
    })(this));
  };

  _prepareEditModal = function(modalEmt) {
    var directionSelect, k, len, o, ref;
    if (this.inputText != null) {
      $('.textarea:first', modalEmt).val(this.inputText);
    } else {
      $('.textarea:first', modalEmt).val('');
    }
    directionSelect = $('.drawHorizontal_select:first', modalEmt);
    if (directionSelect.children().length === 0) {
      ref = this.constructor.actionProperties.modifiables.drawHorizontal.options;
      for (k = 0, len = ref.length; k < len; k++) {
        o = ref[k];
        $.extend(o, o[window.locale]);
        directionSelect.append("<option value='" + o.value + "'>" + o.name + "</option>");
      }
    }
    directionSelect.val('');
    $('.create_button', modalEmt).off('click').on('click', (function(_this) {
      return function(e) {
        var canvas, emt, fontSize, sb;
        emt = $(e.target).closest('.modal-content');
        _this.inputText = $('.textarea:first', emt).val();
        _this.drawHorizontal = parseInt($('.drawHorizontal_select:first', emt).val());
        canvas = document.getElementById(_this.canvasElementId());
        sb = _this.showBalloon;
        _this.showBalloon = false;
        fontSize = _calcFontSizeAbout.call(_this, _this.inputText, canvas.width, canvas.height, _this.isFixedFontSize, _this.drawHorizontal);
        _this.rowWordLength = _calcRowWordLength.call(_this, _this.inputText, canvas.width, canvas.height, fontSize, _this.fontFamily);
        _this.showBalloon = sb;
        _this.fontSize = _calcFontSizeAbout.call(_this, _this.inputText, canvas.width, canvas.height, _this.isFixedFontSize, _this.drawHorizontal);
        _this.saveObj();
        return Navbar.setModeDraw(_this.classDistToken, function() {
          WorktableCommon.changeMode(Constant.Mode.DRAW);
          return _this.refresh(true, function() {
            return Common.hideModalView();
          });
        });
      };
    })(this));
    return $('.back_button', modalEmt).off('click').on('click', (function(_this) {
      return function(e) {
        return Common.hideModalView();
      };
    })(this));
  };

  _calcRowWordLength = function(text, width, height, fontSize, fontFamily) {
    var canvas, char, column, i, k, line, nCanvas, nContext, ref;
    canvas = document.getElementById(this.canvasElementId());
    nCanvas = document.createElement('canvas');
    nCanvas.width = width;
    nCanvas.height = height;
    nContext = nCanvas.getContext('2d');
    nContext.font = fontSize + "px " + fontFamily;
    column = [''];
    line = 0;
    text = text.replace("{br}", "\n", "gm");
    for (i = k = 0, ref = text.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      char = text.charAt(i);
      if (char === "\n" || (this.drawHorizontal === this.constructor.WriteDirectionType.HORIZONTAL && nContext.measureText(column[line] + char).width > width) || (this.drawHorizontal === this.constructor.WriteDirectionType.VERTICAL && _calcVerticalColumnHeight.call(this, column[line] + char, fontSize) > height)) {
        if (char !== "\n" && !this.showBalloon) {
          return column[line].length;
        }
        line += 1;
        column[line] = '';
        if (char === "\n") {
          char = '';
        }
      }
      column[line] += char;
    }
    return null;
  };

  _defaultWorkWidth = function(fontSize, fontFamily) {
    var context, fontSizeKey, nCanvas, wordWidth;
    fontSizeKey = "" + fontSize;
    if ((this._defaultWorkWidth[fontSizeKey] != null) && (this._defaultWorkWidth[fontSizeKey][fontFamily] != null)) {
      return this._defaultWorkWidth[fontSizeKey][fontFamily];
    }
    nCanvas = document.createElement('canvas');
    nCanvas.width = 500;
    nCanvas.height = 500;
    context = nCanvas.getContext('2d');
    context.font = fontSize + "px " + fontFamily;
    wordWidth = context.measureText('あ').width;
    if (this._defaultWorkWidth[fontSizeKey] == null) {
      this._defaultWorkWidth[fontSizeKey] = {};
    }
    return this._defaultWorkWidth[fontSizeKey][fontFamily] = wordWidth;
  };

  return PreloadItemText;

})(CanvasItemBase);

Common.setClassToMap(PreloadItemText.CLASS_DIST_TOKEN, PreloadItemText);

if ((window.itemInitFuncList != null) && (window.itemInitFuncList[PreloadItemText.CLASS_DIST_TOKEN] == null)) {
  if (window.debug) {
    console.log('PreloadItemText loaded');
  }
  window.itemInitFuncList[PreloadItemText.CLASS_DIST_TOKEN] = function(option) {
    if (option == null) {
      option = {};
    }
    if (window.isWorkTable && (PreloadItemText.jsLoaded != null)) {
      PreloadItemArrow.jsLoaded(option);
    }
    if (window.debug) {
      return console.log('PreloadItemText init Finish');
    }
  };
}

//# sourceMappingURL=pi_text.js.map
